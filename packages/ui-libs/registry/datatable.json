{
  "$schema": "https://ui.shadcn.com/schema.json",
  "name": "datatable",
  "type": "registry:component",
  "description": "A powerful, feature-rich React table component built on top of TanStack Table v8",
  "registryDependencies": [
    "table",
    "button",
    "checkbox",
    "input",
    "select",
    "dropdown-menu"
  ],
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/match-sorter-utils",
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "lucide-react"
  ],
  "files": [
    {
      "path": "components/custom/datatable/index.tsx",
      "target": "components/custom/datatable/index.tsx",
      "content": "\"use client\";\n\nimport { useEffect, useMemo, useState, useCallback, useRef } from \"react\";\nimport {\n  useReactTable,\n  getCoreRowModel,\n  flexRender,\n  getFilteredRowModel,\n  getSortedRowModel,\n  getPaginationRowModel,\n  getFacetedRowModel,\n  getFacetedUniqueValues,\n  getFacetedMinMaxValues,\n  FilterFn,\n  SortingFn,\n  Header,\n} from \"@tanstack/react-table\";\nimport FilterInput from '@/components/custom/filter-input';\nimport { Column, ColumnDef, TableOptions } from '@/types/types';\nimport { cn, getValue } from '@/lib/utils';\nimport { RankingInfo } from \"@tanstack/match-sorter-utils\";\nimport DebouncedInput from '@/components/custom/debounced-input';\nimport {\n  Table as DefaultTable,\n  TableBody,\n  TableCell,\n  TableFooter,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { fuzzyFilter, fuzzySort, useExternalState } from '@/components/custom/datatable/actions';\nimport ColumnVisibility from '@/components/custom/column-visibility';\nimport Pagination, { GoToPage, PageSize } from '@/components/custom/pagination';\n\nimport {\n  DndContext,\n  KeyboardSensor,\n  MouseSensor,\n  TouchSensor,\n  closestCenter,\n  useSensor,\n  useSensors,\n  type DragEndEvent,\n} from \"@dnd-kit/core\";\nimport { restrictToHorizontalAxis } from \"@dnd-kit/modifiers\";\nimport {\n  arrayMove,\n  SortableContext,\n  horizontalListSortingStrategy,\n  useSortable,\n} from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\n\nimport { DraggableHeader, DraggableTableCell } from '@/components/custom/draggable-header';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport React from \"react\";\nimport {\n  sanitizeSearchInput,\n  validatePaginationParams,\n  validateSortingParams,\n  RateLimiter,\n} from '@/lib/security';\nimport {\n  defaultTranslations,\n  createTranslator,\n  TableTranslations,\n} from '@/lib/i18n';\nimport { Button } from '@/components/ui/button';\n\ntype DraggableFilterCellProps<TData> = {\n  readonly header: Header<TData, unknown>;\n  readonly colClassName?: string;\n  readonly TableHeadComponent: React.ElementType;\n  readonly translations?: TableTranslations;\n  readonly isTableDragging?: boolean;\n};\n\n// DraggableFilterCell component for filter row\nfunction DraggableFilterCell<TData>({\n  header,\n  colClassName = \"\",\n  TableHeadComponent,\n  translations,\n  isTableDragging = false,\n}: DraggableFilterCellProps<TData>) {\n  const { isDragging, setNodeRef, transform } = useSortable({\n    id: header.column.id,\n  });\n\n  const style: React.CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: CSS.Translate.toString(transform),\n    transition:\n      isDragging || isTableDragging ? \"none\" : \"transform 0.05s ease-out\",\n    zIndex: isDragging ? 1 : 0,\n    width: header.getSize(),\n    minWidth: header.column.columnDef.minSize || 100,\n    maxWidth: header.column.columnDef.maxSize || \"none\",\n  };\n\n  return (\n    <TableHeadComponent\n      key={header.column.id}\n      colSpan={header.colSpan}\n      ref={setNodeRef}\n      style={style}\n      className={cn(\n        (header.column.columnDef as ColumnDef<TData>).headerClassName,\n        (header.column.columnDef as ColumnDef<TData>).className,\n        colClassName\n      )}\n    >\n      <div className=\"w-full\">\n        {flexRender(\n          !header.isPlaceholder && header.column.getCanFilter() ? (\n            <FilterInput\n              column={header.column as Column<TData>}\n              translations={translations}\n            />\n          ) : null,\n          header.getContext()\n        )}\n      </div>\n    </TableHeadComponent>\n  );\n}\n\ndeclare module \"@tanstack/react-table\" {\n  //add fuzzy filter to the filterFns\n  interface FilterFns {\n    fuzzy: FilterFn<unknown>;\n  }\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n\n  interface SortingFns {\n    fuzzy: SortingFn<unknown>;\n  }\n}\n\nexport type DataTableProps<TData> = {\n  readonly tableOptions: TableOptions<TData>;\n  readonly className?: string;\n\n  readonly TableComponent?: React.ElementType;\n  readonly TableHeaderComponent?: React.ElementType;\n  readonly TableRowComponent?: React.ElementType;\n  readonly TableCellComponent?: React.ElementType;\n  readonly TableHeadComponent?: React.ElementType;\n  readonly TableBodyComponent?: React.ElementType;\n  readonly TableFooterComponent?: React.ElementType;\n};\n\nexport function DataTable<TData>({\n  tableOptions,\n  className = \"\",\n  TableComponent = DefaultTable,\n  TableHeaderComponent = TableHeader,\n  TableHeadComponent = TableHead,\n  TableRowComponent = TableRow,\n  TableCellComponent = TableCell,\n  TableBodyComponent = TableBody,\n  TableFooterComponent = TableFooter,\n}: DataTableProps<TData>) {\n  // Validation\n  if (!tableOptions.data || !Array.isArray(tableOptions.data)) {\n    console.warn(\"DataTable: data should be an array\");\n    return <div>No data provided</div>;\n  }\n\n  if (!tableOptions.columns || !Array.isArray(tableOptions.columns)) {\n    console.warn(\"DataTable: columns should be an array\");\n    return <div>No columns provided</div>;\n  }\n\n  // Security: Limit data size to prevent DoS\n  if (tableOptions.data.length > 100000) {\n    console.warn(\n      \"DataTable: Large dataset detected, consider using lazy loading\"\n    );\n  }\n\n  // Rate limiter for lazy loading\n  const rateLimiter = useMemo(() => new RateLimiter(10, 1000), []); // 10 requests per second\n\n  // Create translator function\n  const t = useMemo(() => {\n    const translations = tableOptions.translations || defaultTranslations;\n    return createTranslator(translations);\n  }, [tableOptions.translations]);\n\n  const columns = useMemo(() => {\n    return [\n      ...(tableOptions.rowSelection\n        ? [\n            {\n              id: \"selection\",\n              header: ({ table }) => (\n                <Checkbox\n                  checked={\n                    table.getIsAllPageRowsSelected() ||\n                    (table.getIsSomePageRowsSelected() && \"indeterminate\")\n                  }\n                  onCheckedChange={(value) =>\n                    table.toggleAllPageRowsSelected(!!value)\n                  }\n                  aria-label={t(\"selection.selectAll\")}\n                />\n              ),\n              className: \"!w-8 flex-none\",\n              cell: ({ row }) => (\n                <Checkbox\n                  checked={row.getIsSelected()}\n                  onCheckedChange={(value) => {\n                    row.toggleSelected(!!value);\n                  }}\n                  aria-label={t(\"selection.selectRow\")}\n                />\n              ),\n              enableSorting: false,\n              enableHiding: false,\n              enableResizing: false,\n              reorderable: false,\n              size: 40,\n              minSize: 40,\n              maxSize: 40,\n            } as ColumnDef<TData>,\n          ]\n        : []),\n      ...(tableOptions.columns || []),\n    ];\n  }, [tableOptions.columns, tableOptions.rowSelection, t]);\n  const data = useMemo(() => tableOptions.data, [tableOptions.data]);\n\n  const filterFn: FilterFn<any> = useCallback((row, columnId, filterValue) => {\n    if (!filterValue) return true;\n\n    const column = table.getColumn(columnId);\n    const columnDef = column?.columnDef as ColumnDef<TData>;\n\n    if (!columnDef) return true;\n\n    const filter = columnDef.filter;\n\n    if (!filter) return true;\n\n    const value = getValue(row.original, filter.field, null);\n\n    if (value === null) return true;\n\n    if (Array.isArray(filterValue)) {\n      // Check if it's a range filter (array of two numbers)\n      if (\n        filterValue.length === 2 &&\n        (typeof filterValue[0] === \"number\" ||\n          filterValue[0] === null ||\n          filterValue[0] === \"\") &&\n        (typeof filterValue[1] === \"number\" ||\n          filterValue[1] === null ||\n          filterValue[1] === \"\")\n      ) {\n        const [min, max] = filterValue;\n        const numValue = Number(value);\n        if (min !== null && min !== \"\" && numValue < min) return false;\n        if (max !== null && max !== \"\" && numValue > max) return false;\n        return true;\n      }\n      // Otherwise, treat as multi-select filter (array of strings)\n      if (filterValue.length === 0) return true;\n      const stringValue = String(value);\n      return filterValue.includes(stringValue);\n    }\n\n    if (typeof filterValue === \"string\") {\n      if (filterValue === \"\") return true;\n\n      if (filter?.type === \"boolean\") {\n        return String(value) === filterValue;\n      }\n\n      if (filter?.type === \"select\") {\n        return value === filterValue;\n      }\n\n      return String(value).toLowerCase().includes(filterValue.toLowerCase());\n    }\n\n    return true;\n  }, []);\n\n  const [columnFilters, onColumnFiltersChange] = useExternalState(\n    tableOptions.columnFilters,\n    tableOptions.onColumnFiltersChange,\n    []\n  );\n\n  const [sorting, onSortingChange] = useExternalState(\n    tableOptions.sorting,\n    tableOptions.onSortingChange,\n    []\n  );\n\n  const [pagination, onPaginationChange] = useExternalState(\n    tableOptions.paginationState,\n    tableOptions.onPaginationChange,\n    {\n      pageIndex: 0,\n      pageSize: tableOptions.pagination?.pageSize || 10,\n    }\n  );\n\n  const [columnVisibility, onColumnVisibilityChange] = useExternalState(\n    tableOptions.columnVisibility,\n    tableOptions.onColumnVisibilityChange,\n    {}\n  );\n\n  const [columnOrder, onColumnOrderChange] = useExternalState(\n    tableOptions.columnOrder,\n    tableOptions.onColumnOrderChange,\n    tableOptions.columns\n      .map((col) => col.id!)\n      .filter((id) => id !== \"selection\")\n  );\n\n  const [globalFilter, onGlobalFilterChange] = useExternalState(\n    tableOptions.globalFilter?.globalFilter,\n    tableOptions.globalFilter?.onGlobalFilterChange,\n    \"\"\n  );\n\n  const [rowSelection, onRowSelectionChange] = useExternalState(\n    tableOptions.rowSelection,\n    tableOptions.onRowSelectionChange,\n    {}\n  );\n\n  const [columnSizing, onColumnSizingChange] = useExternalState(\n    tableOptions.columnSizing,\n    tableOptions.onColumnSizingChange,\n    {}\n  );\n\n  const [showFilter, setShowFilter] = useExternalState(\n    tableOptions.showFilter,\n    tableOptions.onShowFilterChange,\n    false\n  );\n\n  // Track drag state to prevent animations during drag operations\n  const [isDragging, setIsDragging] = useState(false);\n\n  useEffect(() => {\n    if (tableOptions.lazy) {\n      const { onLazyLoad } = tableOptions;\n      if (onLazyLoad) {\n        // Rate limiting check\n        if (!rateLimiter.isAllowed(\"lazy-load\")) {\n          console.warn(\"Lazy load rate limit exceeded\");\n          return;\n        }\n\n        // Validate and sanitize parameters\n        const validatedPagination = validatePaginationParams(\n          pagination.pageIndex,\n          pagination.pageSize\n        );\n\n        const validatedSorting = validateSortingParams(sorting);\n\n        const sanitizedGlobalFilter =\n          typeof globalFilter === \"string\"\n            ? sanitizeSearchInput(globalFilter)\n            : \"\";\n\n        // Validate column filters\n        const validatedFilters = columnFilters.map((filter) => ({\n          ...filter,\n          value:\n            typeof filter.value === \"string\"\n              ? sanitizeSearchInput(filter.value)\n              : filter.value,\n        }));\n\n        onLazyLoad({\n          first: validatedPagination.pageIndex * validatedPagination.pageSize,\n          rows: validatedPagination.pageSize,\n          filters: validatedFilters,\n          globalFilter: sanitizedGlobalFilter,\n          page: validatedPagination.pageIndex,\n          sorting: validatedSorting,\n        });\n      }\n    }\n  }, [\n    columnFilters,\n    globalFilter,\n    pagination,\n    sorting,\n    tableOptions.lazy,\n    rateLimiter,\n  ]);\n\n  const table = useReactTable({\n    data,\n    columns,\n    state: {\n      columnFilters: tableOptions.columnFilters ?? columnFilters,\n      globalFilter,\n      sorting,\n      columnVisibility,\n      columnOrder: tableOptions.rowSelection\n        ? [\"selection\", ...columnOrder]\n        : columnOrder,\n      pagination,\n      rowSelection,\n      columnSizing,\n    },\n    rowCount: tableOptions.pagination?.totalRecords || data.length,\n    manualPagination: !!tableOptions.lazy,\n    filterFns: {\n      fuzzy: fuzzyFilter,\n    },\n    sortingFns: {\n      fuzzy: fuzzySort,\n    },\n    manualFiltering: tableOptions.lazy,\n    manualSorting: tableOptions.lazy,\n    globalFilterFn: \"fuzzy\",\n    enableRowSelection: (row) => {\n      if (tableOptions.enableRowSelectionFn) {\n        return tableOptions.enableRowSelectionFn(row);\n      }\n      return tableOptions.rowSelection !== undefined;\n    },\n    // Column sizing configuration\n    enableColumnResizing: tableOptions.enableColumnResizing ?? true,\n    columnResizeMode: tableOptions.columnResizeMode ?? \"onEnd\",\n    columnResizeDirection: tableOptions.columnResizeDirection ?? \"ltr\",\n    defaultColumn: {\n      filterFn: filterFn,\n      size: 150,\n      minSize: 20,\n      maxSize: Number.MAX_SAFE_INTEGER,\n      ...tableOptions.defaultColumn,\n    },\n    onGlobalFilterChange,\n    onColumnFiltersChange,\n    onSortingChange,\n    onPaginationChange,\n    onColumnVisibilityChange,\n    onColumnOrderChange,\n    onRowSelectionChange,\n    onColumnSizingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedRowModel: getFacetedRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    getFacetedMinMaxValues: getFacetedMinMaxValues(),\n    initialState: {\n      columnVisibility: tableOptions.columnVisibility ?? {},\n      columnFilters: tableOptions.columnFilters ?? [],\n      sorting: tableOptions.sorting ?? [],\n      globalFilter: \"\",\n      columnSizing: tableOptions.columnSizing ?? {},\n    },\n  });\n\n  // Memoize sortable items to ensure consistency\n  const sortableItems = useMemo(() => {\n    const tableColumnOrder = table.getState().columnOrder || [];\n    const nonSelectionColumns = tableColumnOrder.filter(\n      (id) => id !== \"selection\"\n    );\n\n    return nonSelectionColumns;\n  }, [table.getState().columnOrder]);\n\n  const handleDragEnd = useCallback(\n    (event: DragEndEvent) => {\n      const { active, over } = event;\n\n      // Reset drag state\n      setIsDragging(false);\n\n      if (active && over && active.id !== over.id) {\n        // Prevent moving the selection column\n        if (active.id === \"selection\") {\n          return;\n        }\n\n        // Get current column order immediately\n        const currentColumnOrder = table.getState().columnOrder || [];\n        const nonSelectionColumns = currentColumnOrder.filter(\n          (id) => id !== \"selection\"\n        );\n\n        const oldIndex = nonSelectionColumns.indexOf(active.id as string);\n        const newIndex = nonSelectionColumns.indexOf(over.id as string);\n\n        if (oldIndex === -1 || newIndex === -1) {\n          console.warn(\"Invalid indices\", { oldIndex, newIndex });\n          return;\n        }\n\n        // Calculate new order\n        const reorderedArray = arrayMove(\n          nonSelectionColumns,\n          oldIndex,\n          newIndex\n        );\n\n        // Update column order immediately\n        onColumnOrderChange(reorderedArray);\n      }\n    },\n    [onColumnOrderChange, table]\n  );\n\n  const handleDragStart = useCallback(() => {\n    setIsDragging(true);\n  }, []);\n\n  const sensors = useSensors(\n    useSensor(MouseSensor, {}),\n    useSensor(TouchSensor, {}),\n    useSensor(KeyboardSensor, {})\n  );\n\n  // Add ref for table container\n  const tableContainerRef = useRef<HTMLDivElement>(null);\n\n  return (\n    <DndContext\n      collisionDetection={closestCenter}\n      modifiers={[restrictToHorizontalAxis]}\n      onDragEnd={handleDragEnd}\n      onDragStart={handleDragStart}\n      sensors={sensors}\n    >\n      <div className={`opal-datatable flex flex-col gap-2 ${className}`}>\n        <div className=\"flex flex-row gap-2 justify-between\">\n          <div className=\"flex flex-row gap-2\">\n            {tableOptions.globalFilter?.show && (\n              <DebouncedInput\n                value={globalFilter ?? \"\"}\n                onChange={(value) => {\n                  const sanitizedValue =\n                    typeof value === \"string\"\n                      ? sanitizeSearchInput(value)\n                      : String(value);\n                  table.setGlobalFilter(sanitizedValue);\n                }}\n                className=\"\"\n                placeholder={t(\"filters.searchAllColumns\")}\n                maxLength={500}\n                type=\"search\"\n              />\n            )}\n            {tableOptions.filter && tableOptions.showFilterButton && (\n              <Button onClick={() => setShowFilter(!showFilter)}>\n                {showFilter ? t(\"filters.hideFilter\") : t(\"filters.showFilter\")}\n              </Button>\n            )}\n          </div>\n          <div className=\"flex flex-row gap-2\">\n            {tableOptions.columnVisibility && (\n              <ColumnVisibility table={table} />\n            )}\n          </div>\n        </div>\n        <div className=\"flex flex-col\" ref={tableContainerRef}>\n          <SortableContext\n            items={sortableItems}\n            strategy={horizontalListSortingStrategy}\n          >\n            <TableComponent>\n              <TableHeaderComponent>\n                {table.getHeaderGroups().map((headerGroup) => (\n                  <>\n                    <TableRowComponent\n                      key={\"header_\" + headerGroup.id}\n                      className={cn(tableOptions.rowClassName)}\n                    >\n                      {headerGroup.headers.map((header) => {\n                        return (\n                          <DraggableHeader\n                            header={header}\n                            colClassName={tableOptions.colClassName}\n                            TableHeadComponent={TableHeadComponent}\n                            key={header.column.id}\n                            reorderable={\n                              header.column.id === \"selection\"\n                                ? false\n                                : tableOptions.reorderable\n                            }\n                            enableColumnResizing={\n                              tableOptions.enableColumnResizing\n                            }\n                          />\n                        );\n                      })}\n                    </TableRowComponent>\n                  </>\n                ))}\n\n                {showFilter && (\n                  <TableRowComponent\n                    className={cn(\n                      tableOptions.filterRowClassName,\n                      tableOptions.rowClassName\n                    )}\n                  >\n                    {table.getHeaderGroups().map((headerGroup) =>\n                      headerGroup.headers.map((header) => {\n                        // Render selection column filter\n                        if (header.column.id === \"selection\") {\n                          return (\n                            <TableHeadComponent\n                              key={header.column.id}\n                              colSpan={header.colSpan}\n                              style={{\n                                width: header.getSize(),\n                                minWidth:\n                                  header.column.columnDef.minSize || 100,\n                                maxWidth:\n                                  header.column.columnDef.maxSize || \"none\",\n                              }}\n                              className={cn(\n                                (header.column.columnDef as ColumnDef<TData>)\n                                  .headerClassName,\n                                (header.column.columnDef as ColumnDef<TData>)\n                                  .className,\n                                tableOptions.colClassName\n                              )}\n                            >\n                              <div className=\"w-full\">\n                                {flexRender(\n                                  header.isPlaceholder ? null : header.column.getCanFilter() ? (\n                                    <FilterInput\n                                      column={header.column as Column<TData>}\n                                      translations={tableOptions.translations}\n                                    />\n                                  ) : null,\n                                  header.getContext()\n                                )}\n                              </div>\n                            </TableHeadComponent>\n                          );\n                        }\n\n                        return (\n                          <DraggableFilterCell<TData>\n                            header={header}\n                            colClassName={tableOptions.colClassName}\n                            TableHeadComponent={TableHeadComponent}\n                            translations={tableOptions.translations}\n                            isTableDragging={isDragging}\n                            key={header.column.id}\n                          />\n                        );\n                      })\n                    )}\n                  </TableRowComponent>\n                )}\n              </TableHeaderComponent>\n              <TableBodyComponent>\n                {table.getRowModel().rows.map((row) => {\n                  return (\n                    <TableRowComponent\n                      key={row.id}\n                      className={tableOptions.filterRowClassName}\n                    >\n                      {row.getVisibleCells().map((cell) => {\n                        return (\n                          <DraggableTableCell<TData>\n                            cell={cell}\n                            colClassName={tableOptions.colClassName}\n                            TableCellComponent={TableCellComponent}\n                            key={cell.column.id}\n                          />\n                        );\n                      })}\n                    </TableRowComponent>\n                  );\n                })}\n              </TableBodyComponent>\n              {table\n                .getAllLeafColumns()\n                .some(\n                  (col) =>\n                    (col.columnDef as ColumnDef<TData>)?.footer !== undefined\n                ) && (\n                <TableFooterComponent>\n                  {table.getFooterGroups().map((footerGroup) => {\n                    if (\n                      !footerGroup.headers.some(\n                        (header) =>\n                          (header.column.columnDef as ColumnDef<TData>)?.footer\n                      )\n                    ) {\n                      return null;\n                    }\n                    return (\n                      <TableRowComponent key={footerGroup.id}>\n                        {footerGroup.headers.map((header) => (\n                          <TableHeadComponent\n                            key={header.id}\n                            colSpan={header.colSpan}\n                            style={{ width: `${header.getSize()}px` }}\n                            className={cn(\n                              (header.column.columnDef as ColumnDef<TData>)\n                                ?.footerClassName,\n                              (header.column.columnDef as ColumnDef<TData>)\n                                .className,\n                              tableOptions.colClassName\n                            )}\n                          >\n                            {header.isPlaceholder\n                              ? null\n                              : flexRender(\n                                  header.column.columnDef.footer,\n                                  header.getContext()\n                                )}\n                          </TableHeadComponent>\n                        ))}\n                      </TableRowComponent>\n                    );\n                  })}\n                </TableFooterComponent>\n              )}\n            </TableComponent>\n          </SortableContext>\n          {tableOptions.pagination && (\n            <div className=\"flex items-center justify-between py-4\">\n              <div className=\"flex flex-wrap items-center justify-between gap-4 px-2 text-sm\">\n                {(\n                  tableOptions.pagination.layout || [\n                    \"total\",\n                    \"pageSize\",\n                    \"goto\",\n                    \"buttons\",\n                  ]\n                ).map((item) => {\n                  switch (item) {\n                    case \"total\":\n                      return (\n                        <span key=\"total\">\n                          {(\n                            tableOptions.pagination!.totalLabel ||\n                            t(\"pagination.totalRecords\", {\n                              total: table.getFilteredRowModel().rows.length,\n                            })\n                          )?.replace(\n                            \"{total}\",\n                            String(table.getFilteredRowModel().rows.length)\n                          )}\n                        </span>\n                      );\n                    case \"pageSize\":\n                      return (\n                        !!tableOptions.pagination!.pageSizeOptions && (\n                          <PageSize\n                            pagination={tableOptions.pagination!}\n                            onSetPageSize={(size: number) => {\n                              table.setPageSize(size);\n                            }}\n                            pageSize={table.getState().pagination.pageSize}\n                            label={tableOptions.pagination!.pageSizeLabel}\n                            translations={tableOptions.translations}\n                          />\n                        )\n                      );\n\n                    case \"goto\":\n                      return (\n                        <GoToPage\n                          label={tableOptions.pagination!.goToPageLabel}\n                          currentPage={table.getState().pagination.pageIndex}\n                          onSetPage={(pageIndex: number) =>\n                            table.setPageIndex(pageIndex)\n                          }\n                          totalPages={table.getPageCount()}\n                          translations={tableOptions.translations}\n                        />\n                      );\n                    case \"buttons\":\n                      return (\n                        <Pagination\n                          canNextPage={table.getCanNextPage()}\n                          canPreviousPage={table.getCanPreviousPage()}\n                          currentPage={table.getState().pagination.pageIndex}\n                          onNext={() => table.nextPage()}\n                          onPrevious={() => table.previousPage()}\n                          onSetPage={(pageIndex: number) =>\n                            table.setPageIndex(pageIndex)\n                          }\n                          totalPages={table.getPageCount()}\n                          className={tableOptions.pagination!.className}\n                          maxVisiblePages={\n                            tableOptions.pagination!.maxVisiblePages\n                          }\n                          mode={tableOptions.pagination!.mode}\n                          translations={tableOptions.translations}\n                        />\n                      );\n                  }\n                })}\n              </div>\n            </div>\n          )}\n        </div>\n      </div>\n    </DndContext>\n  );\n}\n\nexport default DataTable;\nexport { fuzzyFilter, fuzzySort };\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/datatable/actions.ts",
      "target": "components/custom/datatable/actions.ts",
      "content": "\"use client\";\n\nimport {\n  FilterFn,\n  isFunction,\n  SortingFn,\n  sortingFns,\n  Updater,\n} from \"@tanstack/react-table\";\nimport { rankItem, compareItems } from \"@tanstack/match-sorter-utils\";\nimport { OnChangeFn } from \"@tanstack/react-table\";\nimport { SetStateAction, useCallback, useRef, useState } from \"react\";\n\nexport const fuzzyFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed;\n};\n\n// Define a custom fuzzy sort function that will sort by rank if the row has ranking information\nexport const fuzzySort: SortingFn<any> = (rowA, rowB, columnId) => {\n  let dir = 0;\n\n  // Only sort by rank if the column has ranking information\n  if (rowA.columnFiltersMeta[columnId]) {\n    dir = compareItems(\n      rowA.columnFiltersMeta[columnId]?.itemRank!,\n      rowB.columnFiltersMeta[columnId]?.itemRank!\n    );\n  }\n\n  // Provide an alphanumeric fallback for when the item ranks are equal\n  return dir === 0 ? sortingFns.alphanumeric(rowA, rowB, columnId) : dir;\n};\n\nexport function useExternalState<T>(\n  externalState: T | undefined,\n  onExternalChange: ((val: T) => void) | undefined,\n  initialInternalState?: T\n): [T, (val: React.SetStateAction<T>) => void] {\n  const [internalState, setInternalState] = useState<T>(\n    initialInternalState || (externalState as T)\n  );\n\n  const isControlled = externalState !== undefined;\n\n  const value = isControlled ? externalState : internalState;\n\n  const setValue = useCallback(\n    (updater: React.SetStateAction<T>) => {\n      const newValue =\n        typeof updater === \"function\"\n          ? (updater as (prev: T) => T)(value)\n          : updater;\n      if (isControlled) {\n        onExternalChange?.(newValue);\n      } else {\n        setInternalState(newValue);\n      }\n    },\n    [isControlled, value, onExternalChange]\n  );\n\n  return [value, setValue];\n}\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/debounced-input.tsx",
      "target": "components/custom/debounced-input.tsx",
      "content": "\"use client\";\n\nimport React, { InputHTMLAttributes, useEffect, useState, useRef } from \"react\";\nimport { Input } from \"../ui/input\";\nimport { sanitizeSearchInput } from '@/lib/security';\n\n// Simple rate limiter for input changes\nconst useRateLimit = (limit: number = 10, windowMs: number = 1000) => {\n  const requests = useRef<number[]>([]);\n\n  return () => {\n    const now = Date.now();\n    requests.current = requests.current.filter((time) => now - time < windowMs);\n\n    if (requests.current.length >= limit) {\n      return false;\n    }\n\n    requests.current.push(now);\n    return true;\n  };\n};\n\nfunction DebouncedInput({\n  value: initialValue,\n  onChange,\n  debounce = 500,\n  type = \"text\",\n  maxLength = 1000,\n  ...props\n}: {\n  value: string | number | undefined;\n  onChange: (value: string | number | undefined) => void;\n  debounce?: number;\n} & Omit<InputHTMLAttributes<HTMLInputElement>, \"onChange\">) {\n  const [value, setValue] = useState(initialValue);\n  const [isMounted, setIsMounted] = useState(false);\n  const checkRateLimit = useRateLimit();\n  const previousValueRef = useRef<string | number | undefined>(initialValue);\n\n  useEffect(() => {\n    if (type === \"number\") {\n      const numValue = Number(initialValue);\n      if (\n        isNaN(numValue) ||\n        initialValue === null ||\n        initialValue === undefined ||\n        initialValue === \"\"\n      ) {\n        previousValueRef.current = undefined;\n      } else {\n        previousValueRef.current = numValue;\n      }\n    }\n    setValue(initialValue);\n  }, [initialValue]);\n\n  useEffect(() => {\n    if (!isMounted) {\n      setIsMounted(true);\n      return;\n    }\n\n    // Rate limiting check\n    if (!checkRateLimit()) {\n      console.warn(\"Input rate limit exceeded\");\n      return;\n    }\n\n    const timeout = setTimeout(() => {\n      let sanitizedValue:\n        | string\n        | number\n        | undefined\n        | (string & readonly string[])\n        | (number & readonly string[]) = value;\n\n      // Sanitize based on input type\n      if (type === \"text\" || type === \"search\") {\n        sanitizedValue =\n          typeof value === \"string\"\n            ? sanitizeSearchInput(value)\n            : String(value);\n      } else if (type === \"number\") {\n        const numValue = Number(value);\n        if (\n          isNaN(numValue) ||\n          value === null ||\n          value === undefined ||\n          value === \"\"\n        ) {\n          sanitizedValue = undefined;\n        } else {\n          sanitizedValue = Math.max(-1000000, Math.min(1000000, numValue));\n        }\n      }\n\n      // Only call onChange if the value has actually changed\n      if (sanitizedValue !== previousValueRef.current) {\n        previousValueRef.current = sanitizedValue;\n        onChange(sanitizedValue);\n      }\n    }, debounce);\n\n    return () => clearTimeout(timeout);\n  }, [value, debounce, onChange, isMounted, type, checkRateLimit]);\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n\n    // Basic length validation\n    if (inputValue.length > maxLength) {\n      return;\n    }\n\n    // Additional validation for specific input types\n    if (type === \"number\") {\n      // Allow only valid number characters\n      if (!/^-?\\d*\\.?\\d*$/.test(inputValue) && inputValue !== \"\") {\n        return;\n      }\n    }\n\n    setValue(inputValue);\n  };\n\n  return (\n    <Input\n      {...props}\n      type={type}\n      maxLength={maxLength}\n      value={value}\n      onChange={handleInputChange}\n      // Security attributes\n      autoComplete={props.autoComplete || \"off\"}\n      spellCheck={false}\n    />\n  );\n}\n\nexport default DebouncedInput;\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/filter-input.tsx",
      "target": "components/custom/filter-input.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport DebouncedInput from \"./debounced-input\";\nimport { Column, ColumnDef } from '@/types/types';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"../ui/select\";\nimport { cn } from '@/lib/utils';\nimport { sanitizeFilterValue, sanitizeSearchInput } from '@/lib/security';\nimport {\n  TableTranslations,\n  defaultTranslations,\n  createTranslator,\n} from '@/lib/i18n';\n\nfunction FilterInput<T>({\n  column,\n  translations = defaultTranslations,\n}: {\n  column: Column<T>;\n  translations?: TableTranslations;\n}) {\n  const t = createTranslator(translations);\n  const columnFilterValue = column.getFilterValue();\n  const filter = (column.columnDef as ColumnDef<T>)?.filter;\n\n  const sortedUniqueValues = React.useMemo(\n    () =>\n      filter?.type === \"range\"\n        ? []\n        : Array.from(column.getFacetedUniqueValues().keys())\n            .sort()\n            .slice(0, 5000)\n            .map((value) =>\n              typeof value === \"string\" ? sanitizeSearchInput(value) : value\n            ),\n    [column.getFacetedUniqueValues(), filter?.type]\n  );\n\n  if (!filter?.field) return null;\n\n  // Sanitize current filter value\n  const sanitizedFilterValue = React.useMemo(() => {\n    if (!filter?.type) return columnFilterValue;\n    return sanitizeFilterValue(columnFilterValue, filter.type);\n  }, [columnFilterValue, filter?.type]);\n\n  if (filter?.type === \"range\") {\n    const {\n      minPlaceholder = t(\"filters.min\"),\n      maxPlaceholder = t(\"filters.max\"),\n      showLimit = false,\n      minLimit,\n      maxLimit,\n    } = filter ?? {};\n\n    // Validate and sanitize range limits\n    const safeMinLimit =\n      typeof minLimit === \"number\"\n        ? Math.max(-1000000, Math.min(1000000, minLimit))\n        : minLimit;\n    const safeMaxLimit =\n      typeof maxLimit === \"number\"\n        ? Math.max(-1000000, Math.min(1000000, maxLimit))\n        : maxLimit;\n\n    return (\n      <div className=\"flex space-x-1 w-full\">\n        <DebouncedInput\n          type=\"number\"\n          min={\n            safeMinLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[0] ?? \"\")\n              : safeMinLimit\n          }\n          max={\n            safeMaxLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[1] ?? \"\")\n              : safeMaxLimit\n          }\n          value={(sanitizedFilterValue as [number, number])?.[0] ?? \"\"}\n          onChange={(value) => {\n            // Validate and sanitize numeric input\n            const numValue =\n              value === \"\" || value === null || value === undefined\n                ? undefined\n                : Number(value);\n\n            if (\n              numValue !== undefined &&\n              (isNaN(numValue) || numValue < -1000000 || numValue > 1000000)\n            ) {\n              return; // Reject invalid values\n            }\n            column.setFilterValue((old: [number, number]) => {\n              if (numValue === undefined && old?.[1] === undefined) {\n                return undefined;\n              }\n              return [numValue, old?.[1]];\n            });\n          }}\n          placeholder={`${sanitizeSearchInput(minPlaceholder)} ${\n            showLimit\n              ? safeMinLimit === \"faceted\"\n                ? column.getFacetedMinMaxValues()?.[0] !== undefined\n                  ? `(${column.getFacetedMinMaxValues()?.[0]})`\n                  : \"\"\n                : `(${safeMinLimit})`\n              : \"\"\n          }`}\n          className=\"flex-1 min-w-16 h-8\"\n        />\n        <DebouncedInput\n          type=\"number\"\n          min={\n            safeMinLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[0] ?? \"\")\n              : safeMinLimit\n          }\n          max={\n            safeMaxLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[1] ?? \"\")\n              : safeMaxLimit\n          }\n          value={(sanitizedFilterValue as [number, number])?.[1] ?? \"\"}\n          onChange={(value) => {\n            // Validate and sanitize numeric input\n            const numValue =\n              value === \"\" || value === null || value === undefined\n                ? undefined\n                : Number(value);\n            if (\n              numValue !== undefined &&\n              (isNaN(numValue) || numValue < -1000000 || numValue > 1000000)\n            ) {\n              return; // Reject invalid values\n            }\n            column.setFilterValue((old: [number, number]) => {\n              if (numValue === undefined && old?.[0] === undefined) {\n                return undefined;\n              }\n              return [old?.[0], numValue];\n            });\n          }}\n          placeholder={`${sanitizeSearchInput(maxPlaceholder)} ${\n            showLimit\n              ? safeMaxLimit === \"faceted\"\n                ? column.getFacetedMinMaxValues()?.[1] !== undefined\n                  ? `(${column.getFacetedMinMaxValues()?.[1]})`\n                  : \"\"\n                : `(${safeMaxLimit})`\n              : \"\"\n          }`}\n          className=\"flex-1 min-w-16 h-8\"\n        />\n      </div>\n    );\n  }\n\n  if (filter?.type === \"select\") {\n    const {\n      options,\n      optionLabel = \"label\",\n      optionValue = \"value\",\n      allLabel = t(\"filters.all\"),\n    } = filter ?? {};\n\n    // Sanitize options\n    const safeOptions = (options ?? sortedUniqueValues).slice(0, 1000); // Limit options to prevent DoS\n\n    return (\n      <Select\n        value={(sanitizedFilterValue as string) ?? \"all\"}\n        onValueChange={(value) => {\n          const sanitizedValue = sanitizeSearchInput(value);\n          column.setFilterValue(sanitizedValue === \"all\" ? \"\" : sanitizedValue);\n        }}\n      >\n        <SelectTrigger className=\"h-8 w-full\">\n          <SelectValue placeholder={sanitizeSearchInput(allLabel)} />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"all\">{sanitizeSearchInput(allLabel)}</SelectItem>\n          {safeOptions.map((option: any, index: number) => {\n            const value =\n              typeof option === \"object\"\n                ? sanitizeSearchInput(String(option[optionValue]))\n                : sanitizeSearchInput(String(option));\n            const label =\n              typeof option === \"object\"\n                ? sanitizeSearchInput(String(option[optionLabel]))\n                : sanitizeSearchInput(String(option));\n            return (\n              <SelectItem value={value} key={`${value}-${index}`}>\n                {label}\n              </SelectItem>\n            );\n          })}\n        </SelectContent>\n      </Select>\n    );\n  }\n\n  if (filter?.type === \"boolean\") {\n    const {\n      trueLabel = t(\"filters.true\"),\n      falseLabel = t(\"filters.false\"),\n      allLabel = t(\"filters.all\"),\n    } = filter ?? {};\n    return (\n      <Select\n        value={(sanitizedFilterValue as string) ?? \"all\"}\n        onValueChange={(value) => {\n          // Only allow specific boolean values\n          if (![\"all\", \"true\", \"false\"].includes(value)) return;\n          column.setFilterValue(value === \"all\" ? \"\" : value);\n        }}\n      >\n        <SelectTrigger className=\"h-8 w-full\">\n          <SelectValue placeholder={sanitizeSearchInput(allLabel)} />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"all\">{sanitizeSearchInput(allLabel)}</SelectItem>\n          <SelectItem value=\"true\">{sanitizeSearchInput(trueLabel)}</SelectItem>\n          <SelectItem value=\"false\">\n            {sanitizeSearchInput(falseLabel)}\n          </SelectItem>\n        </SelectContent>\n      </Select>\n    );\n  }\n\n  if (filter?.type === \"text\") {\n    return (\n      <>\n        {filter?.showList && (\n          <datalist id={column.id + \"list\"}>\n            {sortedUniqueValues\n              .slice(0, 100)\n              .map((value: any, index: number) => (\n                <option value={value} key={`${value}-${index}`} />\n              ))}\n          </datalist>\n        )}\n        <DebouncedInput\n          className={cn(\"w-full h-8\", filter?.className)}\n          onChange={(value) => {\n            const sanitizedValue = sanitizeSearchInput(String(value));\n            column.setFilterValue(sanitizedValue);\n          }}\n          placeholder={`${sanitizeSearchInput(filter?.field)} ${filter?.showTotal ? `(${Math.min(column.getFacetedUniqueValues().size, 9999)})` : \"\"}`}\n          type=\"text\"\n          value={(sanitizedFilterValue ?? \"\") as string}\n          list={filter?.showList ? column.id + \"list\" : undefined}\n          maxLength={1000} // Prevent extremely long inputs\n        />\n      </>\n    );\n  }\n\n  if (filter?.type === \"custom\") {\n    const { component: CustomComponent, ...rest } = filter;\n    // Note: Custom components should implement their own security measures\n    return <CustomComponent column={column} {...rest} />;\n  }\n\n  return null;\n}\n\nexport default FilterInput;\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/column-visibility.tsx",
      "target": "components/custom/column-visibility.tsx",
      "content": "\"use client\";\n\nimport { flexRender, isFunction, Table } from \"@tanstack/react-table\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuTrigger,\n  DropdownMenuCheckboxItem,\n} from \"../ui/dropdown-menu\";\nimport { Button } from \"../ui/button\";\n\nexport default function ColumnVisibility({\n  table,\n  label,\n}: {\n  table: Table<any>;\n  label?: string;\n}) {\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"outline\" className=\"ml-auto\">\n          {label || \"Columns\"}\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"end\">\n        {table\n          .getAllColumns()\n          .filter((column) => column.getCanHide())\n          .map((column) => {\n            return (\n              <DropdownMenuCheckboxItem\n                key={column.id}\n                className=\"capitalize\"\n                checked={column.getIsVisible()}\n                onCheckedChange={(value) => column.toggleVisibility(!!value)}\n              >\n                {isFunction(column.columnDef.header)\n                  ? flexRender(\n                      column.columnDef.header,\n                      table\n                        .getHeaderGroups()\n                        .find((headerGroup) =>\n                          headerGroup.headers.some(\n                            (header) => header.id === column.id\n                          )\n                        )\n                        ?.headers.find((header) => header.id === column.id)!\n                        .getContext()!\n                    )\n                  : column.columnDef.header || column.id}\n              </DropdownMenuCheckboxItem>\n            );\n          })}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/pagination.tsx",
      "target": "components/custom/pagination.tsx",
      "content": "\"use client\";\n\nimport React, { useCallback } from \"react\";\nimport { Button } from \"../ui/button\";\nimport { cn } from '@/lib/utils';\nimport {\n  ChevronLeftIcon,\n  ChevronRightIcon,\n  ChevronsLeftIcon,\n  ChevronsRightIcon,\n  Ellipsis,\n} from \"lucide-react\";\nimport { PaginationOptions } from '@/types/types';\nimport DebouncedInput from \"./debounced-input\";\nimport { Select, SelectContent, SelectItem, SelectTrigger } from \"../ui/select\";\nimport {\n  TableTranslations,\n  defaultTranslations,\n  createTranslator,\n} from '@/lib/i18n';\n\ntype Props = {\n  totalPages: number;\n  currentPage: number;\n  canPreviousPage: boolean;\n  canNextPage: boolean;\n  onPrevious: () => void;\n  onNext: () => void;\n  onSetPage: (page: number) => void;\n  className?: string;\n  mode?: \"default\" | \"compact\" | \"advanced\";\n  maxVisiblePages?: number;\n  translations?: TableTranslations;\n};\n\nexport default function Pagination({\n  onNext,\n  onPrevious,\n  onSetPage,\n  canNextPage,\n  canPreviousPage,\n  totalPages = 0,\n  currentPage = 0,\n  className,\n  mode = \"default\",\n  maxVisiblePages = 7,\n  translations = defaultTranslations,\n}: Props) {\n  const t = createTranslator(translations);\n\n  const getVisiblePages = useCallback(() => {\n    const pages = [];\n\n    switch (mode) {\n      case \"advanced\": {\n        if (totalPages <= maxVisiblePages) {\n          // Case 1: 7 veya daha az sayfa - hepsini göster (1,2,3,4,5,6,7)\n          for (let i = 0; i < totalPages; i++) {\n            pages.push(i);\n          }\n        } else {\n          // 7'den fazla sayfa için case hesaplama\n          const leftPages = Math.floor((maxVisiblePages - 3) / 2); // Sol tarafta kaç sayfa (ellipsis ve first/last hariç)\n          const rightPages = maxVisiblePages - 3 - leftPages; // Sağ tarafta kaç sayfa\n\n          const isNearStart = currentPage < leftPages + 1;\n          const isNearEnd = currentPage >= totalPages - rightPages - 1;\n\n          if (isNearStart) {\n            // Case 2: Başlangıçta (1,2,3,4,5,...,12)\n            for (let i = 0; i < maxVisiblePages - 2; i++) {\n              // maxVisiblePages-2 = 5 sayfa\n              pages.push(i);\n            }\n            pages.push(-1); // ellipsis\n            pages.push(totalPages - 1); // last page\n          } else if (isNearEnd) {\n            // Case 4: Sonda (1,...,8,9,10,11,12)\n            pages.push(0); // first page\n            pages.push(-1); // ellipsis\n            for (\n              let i = totalPages - (maxVisiblePages - 2);\n              i < totalPages;\n              i++\n            ) {\n              // Son 5 sayfa\n              pages.push(i);\n            }\n          } else {\n            // Case 3: Ortada (1,...,5,6,7,...,12)\n            pages.push(0); // first page\n            pages.push(-1); // left ellipsis\n\n            // Ortada 3 sayfa: current-1, current, current+1\n            const middlePages = maxVisiblePages - 4; // 4 = first + 2 ellipsis + last\n            const startMiddle = currentPage - Math.floor(middlePages / 2);\n\n            for (let i = 0; i < middlePages; i++) {\n              pages.push(startMiddle + i);\n            }\n\n            pages.push(-2); // right ellipsis\n            pages.push(totalPages - 1); // last page\n          }\n        }\n        break;\n      }\n\n      case \"default\": {\n        if (totalPages <= maxVisiblePages) {\n          for (let i = 0; i < totalPages; i++) {\n            pages.push(i);\n          }\n        } else {\n          // 5'ten fazla sayfa: kaydırmalı window + ellipsis\n          const isNearEnd = currentPage >= totalPages - maxVisiblePages + 1;\n\n          if (isNearEnd) {\n            // Son kısımda: son 5 sayfayı göster (8,9,10,11,12)\n            for (let i = totalPages - maxVisiblePages; i < totalPages; i++) {\n              pages.push(i);\n            }\n          } else {\n            // Başta veya ortada: current'tan başlayıp 4 sayfa + ellipsis + last\n            const startPage = Math.max(0, currentPage);\n            for (let i = startPage; i < startPage + maxVisiblePages - 1; i++) {\n              pages.push(i);\n            }\n            pages.push(-1); // ellipsis\n            pages.push(totalPages - 1); // last page\n          }\n        }\n        break;\n      }\n\n      case \"compact\": {\n        if (totalPages <= maxVisiblePages) {\n          for (let i = 0; i < totalPages; i++) {\n            pages.push(i);\n          }\n        } else {\n          let start = Math.max(\n            0,\n            currentPage - Math.floor(maxVisiblePages / 2)\n          );\n          let end = Math.min(totalPages - 1, start + maxVisiblePages - 1);\n\n          if (end === totalPages - 1) {\n            start = Math.max(0, end - maxVisiblePages + 1);\n          }\n\n          for (let i = start; i <= end; i++) {\n            pages.push(i);\n          }\n        }\n        break;\n      }\n    }\n\n    return pages;\n  }, [totalPages, currentPage, mode, maxVisiblePages]);\n\n  return (\n    <div className={cn(\"flex items-center gap-1\", className)}>\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onSetPage(0)}\n        disabled={!canPreviousPage}\n        aria-label={t(\"pagination.first\")}\n      >\n        <ChevronsLeftIcon className=\"h-4 w-4\" />\n      </Button>\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onPrevious()}\n        disabled={!canPreviousPage}\n        aria-label={t(\"pagination.previous\")}\n      >\n        <ChevronLeftIcon className=\"h-4 w-4\" />\n      </Button>\n\n      {/* Page Numbers */}\n      {getVisiblePages().map((page, index) => {\n        if (page === -1 || page === -2) {\n          return (\n            <span\n              key={index}\n              className=\"size-9 flex items-center justify-center text-gray-500\"\n            >\n              <Ellipsis className=\"h-4 w-4\" />\n            </span>\n          );\n        }\n\n        return (\n          <Button\n            key={index}\n            variant={currentPage === page ? \"default\" : \"ghost\"}\n            size=\"icon\"\n            onClick={() => onSetPage(page)}\n          >\n            {page + 1}\n          </Button>\n        );\n      })}\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onNext()}\n        disabled={!canNextPage}\n        aria-label={t(\"pagination.next\")}\n      >\n        <ChevronRightIcon className=\"h-4 w-4\" />\n      </Button>\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onSetPage(totalPages - 1)}\n        disabled={!canNextPage || totalPages === 0}\n        aria-label={t(\"pagination.last\")}\n      >\n        <ChevronsRightIcon className=\"h-4 w-4\" />\n      </Button>\n    </div>\n  );\n}\n\ntype GoToPageProps = {\n  totalPages: number;\n  currentPage: number;\n  onSetPage: (page: number) => void;\n  className?: string;\n  label?: string;\n  translations?: TableTranslations;\n};\n\nexport function GoToPage({\n  currentPage,\n  onSetPage,\n  totalPages,\n  className,\n  label,\n  translations = defaultTranslations,\n}: GoToPageProps) {\n  const t = createTranslator(translations);\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      {label && (\n        <span className=\"text-sm text-gray-700\">\n          {label || t(\"pagination.goToPage\")}\n        </span>\n      )}\n      <DebouncedInput\n        type=\"number\"\n        min={1}\n        max={totalPages}\n        value={currentPage + 1}\n        onChange={(value) => {\n          const page = value ? Number(value) - 1 : 0;\n          onSetPage(page);\n        }}\n        className=\"w-16 h-8 border border-gray-300 rounded-md px-2\"\n        placeholder={t(\"pagination.page\")}\n      />\n      <span className=\"text-sm text-gray-700\">\n        {t(\"pagination.of\")} {totalPages}\n      </span>\n    </div>\n  );\n}\n\nexport function PageSize({\n  pageSize,\n  className,\n  onSetPageSize,\n  pagination,\n  label,\n  translations = defaultTranslations,\n}: {\n  onSetPageSize: (size: number) => void;\n  pageSize: number;\n  className?: string;\n  pagination: PaginationOptions;\n  label?: string;\n  translations?: TableTranslations;\n}) {\n  const t = createTranslator(translations);\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      {label && (\n        <span className=\"text-sm truncate text-gray-700\">\n          {label || t(\"pagination.rowsPerPage\")}\n        </span>\n      )}\n      <Select\n        value={pageSize.toString()}\n        onValueChange={(e: string) => {\n          const size = parseInt(e, 10);\n          if (!isNaN(size) && size > 0) {\n            onSetPageSize(size);\n          }\n        }}\n      >\n        <SelectTrigger>\n          <span className=\"text-sm text-gray-700\">{pageSize}</span>\n        </SelectTrigger>\n        <SelectContent>\n          {pagination.pageSizeOptions?.map((size) => (\n            <SelectItem key={size} value={size.toString()}>\n              {size}\n            </SelectItem>\n          ))}\n        </SelectContent>\n      </Select>\n    </div>\n  );\n}\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/draggable-header.tsx",
      "target": "components/custom/draggable-header.tsx",
      "content": "\"use client\";\n\nimport { flexRender, Header } from \"@tanstack/react-table\";\nimport React, { CSSProperties } from \"react\";\n\nimport { useSortable } from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { TableCell, TableHead } from \"../ui/table\";\nimport { ColumnDef } from '@/types/types';\nimport { ArrowDownUp, MenuIcon, SortAsc, SortDesc } from \"lucide-react\";\nimport { cn } from '@/lib/utils';\nimport { Button } from \"../ui/button\";\nimport { Cell } from \"@tanstack/react-table\";\nimport ColumnResizeHandle from \"./column-resize-handle\";\n\ntype DraggableHeaderProps<T> = {\n  header: Header<T, unknown>;\n  colClassName?: string;\n  TableHeadComponent?: React.ElementType;\n  reorderable?: boolean;\n  enableColumnResizing?: boolean;\n};\n\nexport function DraggableHeader<T>({\n  header,\n  TableHeadComponent = TableHead,\n  colClassName = \"\",\n  reorderable = false,\n  enableColumnResizing = false,\n}: DraggableHeaderProps<T>) {\n  const isSelectionColumn = header.column.id === \"selection\";\n\n  const { attributes, isDragging, listeners, setNodeRef, transform } =\n    useSortable({\n      id: header.column.id,\n      disabled: isSelectionColumn || !reorderable,\n    });\n\n  const style: CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: isSelectionColumn\n      ? undefined\n      : CSS.Translate.toString(transform),\n    transition: isSelectionColumn\n      ? undefined\n      : isDragging\n        ? \"none\"\n        : \"transform 0.05s ease-out\",\n    zIndex: isDragging ? 1 : 0,\n    width: header.getSize(),\n    minWidth: header.column.columnDef.minSize || 100,\n    maxWidth: header.column.columnDef.maxSize || \"none\",\n  };\n\n  return (\n    <TableHeadComponent\n      colSpan={header.colSpan}\n      ref={setNodeRef}\n      style={style}\n      onClick={() => {\n        if (\n          header.column.getCanSort() &&\n          (header.column.columnDef as ColumnDef<T>).enableSorting\n        ) {\n          header.column.toggleSorting();\n        }\n      }}\n      className={cn(\n        (header.column.columnDef as ColumnDef<T>).headerClassName,\n        (header.column.columnDef as ColumnDef<T>).className,\n        colClassName,\n        !!(header.column.columnDef as ColumnDef<T>).enableSorting &&\n          \"cursor-pointer select-none\",\n        \"relative\",\n        enableColumnResizing && \"group\"\n      )}\n    >\n      {header.isPlaceholder ? null : (\n        <>\n          <div className=\"flex items-center justify-between gap-2 w-full\">\n            <div className=\"flex items-center gap-1 flex-1 min-w-0\">\n              <span className=\"truncate\">\n                {flexRender(\n                  header.column.columnDef.header,\n                  header.getContext()\n                )}\n              </span>\n              {(!!(header.column.columnDef as ColumnDef<T>).enableSorting &&\n                {\n                  asc: <SortAsc className=\"inline size-4 flex-shrink-0\" />,\n                  desc: <SortDesc className=\"inline size-4 flex-shrink-0\" />,\n                }[header.column.getIsSorted() as string]) ?? (\n                <ArrowDownUp className=\"inline size-4 flex-shrink-0\" />\n              )}\n            </div>\n            {reorderable &&\n              header.column.id !== \"selection\" &&\n              ((header.column.columnDef as ColumnDef<T>).reorderable ??\n                true) && (\n                <Button\n                  variant=\"ghost\"\n                  className=\"size-6 p-0 flex-shrink-0\"\n                  {...attributes}\n                  {...listeners}\n                >\n                  <span className=\"sr-only\">Drag to reorder</span>\n                  <MenuIcon className=\"size-4\" />\n                </Button>\n              )}\n          </div>\n          {enableColumnResizing && <ColumnResizeHandle header={header} />}\n        </>\n      )}\n    </TableHeadComponent>\n  );\n}\n\nexport function DraggableTableCell<T>({\n  cell,\n  colClassName = \"\",\n  TableCellComponent = TableCell,\n}: {\n  cell: Cell<T, unknown>;\n  colClassName?: string;\n  TableCellComponent?: React.ElementType;\n}) {\n  const isSelectionColumn = cell.column.id === \"selection\";\n\n  const { isDragging, setNodeRef, transform } = useSortable({\n    id: cell.column.id,\n    disabled: isSelectionColumn,\n  });\n\n  const style: CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: isSelectionColumn\n      ? undefined\n      : CSS.Translate.toString(transform),\n    transition: isSelectionColumn\n      ? undefined\n      : isDragging\n        ? \"none\"\n        : \"transform 0.05s ease-out\",\n    zIndex: isDragging ? 1 : 0,\n    width: cell.column.getSize(),\n    minWidth: cell.column.columnDef.minSize || 100,\n    maxWidth: cell.column.columnDef.maxSize || \"none\",\n  };\n\n  return (\n    <TableCellComponent\n      style={style}\n      ref={setNodeRef}\n      className={cn(\n        (cell.column.columnDef as ColumnDef<T>).className,\n        colClassName\n      )}\n    >\n      <div className=\"truncate\">\n        {flexRender(cell.column.columnDef.cell, cell.getContext())}\n      </div>\n    </TableCellComponent>\n  );\n}\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/column-resize-handle/index.tsx",
      "target": "components/custom/column-resize-handle/index.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport { Header } from \"@tanstack/react-table\";\nimport { cn } from '@/lib/utils';\n\ninterface ColumnResizeHandleProps<TData> {\n  header: Header<TData, unknown>;\n  className?: string;\n}\n\nexport function ColumnResizeHandle<TData>({\n  header,\n  className,\n}: ColumnResizeHandleProps<TData>) {\n  const { column } = header;\n  const isResizing = column.getIsResizing();\n\n  if (!column.getCanResize()) {\n    return null;\n  }\n\n  return (\n    <div\n      className={cn(\n        \"absolute right-0 top-0 h-full w-1 cursor-col-resize select-none touch-none bg-transparent hover:bg-blue-500 active:bg-blue-600 focus:bg-blue-500 focus:outline-none\",\n        isResizing && \"bg-blue-500\",\n        className\n      )}\n      onMouseDown={header.getResizeHandler()}\n      onTouchStart={header.getResizeHandler()}\n      role=\"separator\"\n      aria-label={`Resize ${header.column.id} column`}\n      aria-orientation=\"vertical\"\n      tabIndex={0}\n      onKeyDown={(e) => {\n        if (e.key === \"Enter\" || e.key === \" \") {\n          e.preventDefault();\n          // Could implement keyboard-based resizing here\n        }\n      }}\n      style={{\n        transform: \"translateX(50%)\",\n      }}\n    >\n      <div className=\"h-full w-full\" />\n    </div>\n  );\n}\n\nexport default ColumnResizeHandle;\n",
      "type": "registry:file"
    },
    {
      "path": "lib/utils.ts",
      "target": "lib/utils.ts",
      "content": "import { GetFieldType } from \"./utils.types\";\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\nexport function getValue<\n  TData,\n  TPath extends string,\n  TDefault = GetFieldType<TData, TPath>,\n>(\n  data: TData,\n  path: TPath,\n  defaultValue?: TDefault\n): GetFieldType<TData, TPath> | TDefault {\n  const value = path\n    .split(/[.[\\]]/)\n    .filter(Boolean)\n    .reduce<GetFieldType<TData, TPath>>(\n      (value, key) => (value as any)?.[key],\n      data as any\n    );\n\n  return value !== undefined ? value : (defaultValue as TDefault);\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/utils.types.ts",
      "target": "lib/utils.types.ts",
      "content": "type DepthCounter = [never, 1, 2, 3, 4, 5, 6];\n\nexport type DeepKeys<\n  T,\n  Prefix extends string = \"\",\n  Depth extends number = 6,\n> = [Depth] extends [never]\n  ? never\n  : T extends object\n    ? {\n        [K in keyof T]-?: K extends string\n          ?\n              | `${Prefix}${Prefix extends \"\" ? \"\" : \".\"}${K}`\n              | DeepKeys<\n                  T[K],\n                  `${Prefix}${Prefix extends \"\" ? \"\" : \".\"}${K}`,\n                  Prev<Depth>\n                >\n          : never;\n      }[keyof T]\n    : \"\";\n\ntype Prev<N extends number> = DepthCounter[N];\n\ntype FieldWithPossiblyUndefined<T, key> =\n  | GetFieldType<Exclude<T, undefined>, key>\n  | Extract<T, undefined>;\n\ntype GetIndexedField<T, K> = K extends keyof T\n  ? T[K]\n  : K extends `${number}`\n    ? \"0\" extends keyof T\n      ? undefined\n      : number extends keyof T\n        ? T[number]\n        : undefined\n    : undefined;\n\nexport type GetFieldType<T, P> = P extends `${infer Left}.${infer Right}`\n  ? Left extends keyof T\n    ? FieldWithPossiblyUndefined<T[Left], Right>\n    : Left extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ? FieldWithPossiblyUndefined<\n            | GetIndexedField<Exclude<T[FieldKey], undefined>, IndexKey>\n            | Extract<T[FieldKey], undefined>,\n            Right\n          >\n        : undefined\n      : undefined\n  : P extends keyof T\n    ? T[P]\n    : P extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ?\n            | GetIndexedField<Exclude<T[FieldKey], undefined>, IndexKey>\n            | Extract<T[FieldKey], undefined>\n        : undefined\n      : undefined;\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/security.ts",
      "target": "lib/security.ts",
      "content": "/**\n * Security utilities for input sanitization and validation\n */\n\n/**\n * Sanitizes HTML content to prevent XSS attacks\n */\nexport function sanitizeHtml(input: string): string {\n  if (typeof input !== \"string\") return \"\";\n\n  return (\n    input\n      // Remove script tags\n      .replace(/<script\\b[^<]*(?:(?!<\\/script>)<[^<]*)*<\\/script>/gi, \"\")\n      // Remove javascript: URLs\n      .replace(/javascript:/gi, \"\")\n      // Remove on* event handlers\n      .replace(/\\s*on\\w+\\s*=\\s*[\"'][^\"']*[\"']/gi, \"\")\n      // Remove data: URLs (except safe ones)\n      .replace(/data:(?!image\\/(png|jpe?g|gif|svg\\+xml))[^;]*;/gi, \"\")\n      // Remove style attributes that could contain expressions\n      .replace(/style\\s*=\\s*[\"'][^\"']*expression\\s*\\([^\"']*[\"']/gi, \"\")\n  );\n}\n\n/**\n * Sanitizes search input to prevent injection attacks\n */\nexport function sanitizeSearchInput(input: string): string {\n  if (typeof input !== \"string\") return \"\";\n\n  return (\n    input\n      // Remove SQL injection patterns\n      .replace(/['\";\\\\]/g, \"\")\n      // Remove potential script injections\n      .replace(/<[^>]*>/g, \"\")\n      // Limit length to prevent DoS\n      .slice(0, 1000)\n      .trim()\n  );\n}\n\n/**\n * Validates and sanitizes column filter values\n */\nexport function sanitizeFilterValue(value: any, filterType: string): any {\n  if (value === null || value === undefined) return value;\n\n  switch (filterType) {\n    case \"text\":\n    case \"custom\":\n      return typeof value === \"string\" ? sanitizeSearchInput(value) : \"\";\n\n    case \"select\":\n    case \"multi-select\":\n      if (Array.isArray(value)) {\n        return value.map((v) =>\n          typeof v === \"string\" ? sanitizeSearchInput(v) : \"\"\n        );\n      }\n      return typeof value === \"string\" ? sanitizeSearchInput(value) : \"\";\n\n    case \"range\":\n      if (Array.isArray(value)) {\n        return value.map((v) => {\n          const num = Number(v);\n          return isNaN(num) ? null : Math.max(-1000000, Math.min(1000000, num));\n        });\n      }\n      const num = Number(value);\n      return isNaN(num) ? null : Math.max(-1000000, Math.min(1000000, num));\n\n    case \"boolean\":\n      return typeof value === \"boolean\" ? value : Boolean(value);\n\n    case \"date\":\n    case \"date-range\":\n      if (Array.isArray(value)) {\n        return value.map((v) => {\n          const date = new Date(v);\n          return isNaN(date.getTime())\n            ? null\n            : date.toISOString().split(\"T\")[0];\n        });\n      }\n      const date = new Date(value);\n      return isNaN(date.getTime()) ? null : date.toISOString().split(\"T\")[0];\n\n    default:\n      return typeof value === \"string\" ? sanitizeSearchInput(value) : value;\n  }\n}\n\n/**\n * Validates pagination parameters to prevent abuse\n */\nexport function validatePaginationParams(\n  pageIndex: number,\n  pageSize: number\n): {\n  pageIndex: number;\n  pageSize: number;\n} {\n  const safePageIndex = Math.max(\n    0,\n    Math.min(10000, Math.floor(Number(pageIndex) || 0))\n  );\n  const safePageSize = Math.max(\n    1,\n    Math.min(1000, Math.floor(Number(pageSize) || 10))\n  );\n\n  return {\n    pageIndex: safePageIndex,\n    pageSize: safePageSize,\n  };\n}\n\n/**\n * Validates sorting parameters\n */\nexport function validateSortingParams(sorting: any[]): any[] {\n  if (!Array.isArray(sorting)) return [];\n\n  return sorting\n    .slice(0, 10) // Limit number of sort columns\n    .map((sort) => {\n      if (!sort || typeof sort !== \"object\") return null;\n\n      const id =\n        typeof sort.id === \"string\" ? sanitizeSearchInput(sort.id) : \"\";\n      const desc = Boolean(sort.desc);\n\n      return id ? { id, desc } : null;\n    })\n    .filter(Boolean);\n}\n\n/**\n * Rate limiting utility for preventing abuse\n */\nexport class RateLimiter {\n  private requests: Map<string, number[]> = new Map();\n  private readonly maxRequests: number;\n  private readonly windowMs: number;\n\n  constructor(maxRequests: number = 100, windowMs: number = 60000) {\n    this.maxRequests = maxRequests;\n    this.windowMs = windowMs;\n  }\n\n  isAllowed(identifier: string): boolean {\n    const now = Date.now();\n    const requests = this.requests.get(identifier) || [];\n\n    // Remove old requests outside the window\n    const validRequests = requests.filter((time) => now - time < this.windowMs);\n\n    if (validRequests.length >= this.maxRequests) {\n      return false;\n    }\n\n    validRequests.push(now);\n    this.requests.set(identifier, validRequests);\n\n    return true;\n  }\n\n  reset(identifier?: string): void {\n    if (identifier) {\n      this.requests.delete(identifier);\n    } else {\n      this.requests.clear();\n    }\n  }\n}\n\n/**\n * Content Security Policy helpers\n */\nexport const CSP_DIRECTIVES = {\n  \"default-src\": \"'self'\",\n  \"script-src\": \"'self' 'unsafe-inline'\",\n  \"style-src\": \"'self' 'unsafe-inline'\",\n  \"img-src\": \"'self' data: https:\",\n  \"font-src\": \"'self' data:\",\n  \"connect-src\": \"'self'\",\n  \"frame-src\": \"'none'\",\n  \"object-src\": \"'none'\",\n  \"base-uri\": \"'self'\",\n  \"form-action\": \"'self'\",\n} as const;\n\n/**\n * Validates file uploads (if used in custom cells)\n */\nexport function validateFileUpload(file: File): {\n  isValid: boolean;\n  error?: string;\n} {\n  const maxSize = 10 * 1024 * 1024; // 10MB\n  const allowedTypes = [\n    \"image/jpeg\",\n    \"image/png\",\n    \"image/gif\",\n    \"image/webp\",\n    \"application/pdf\",\n    \"text/csv\",\n    \"application/vnd.ms-excel\",\n    \"application/vnd.openxmlformats-officedocument.spreadsheetml.sheet\",\n  ];\n\n  if (file.size > maxSize) {\n    return {\n      isValid: false,\n      error: \"File size exceeds 10MB limit\",\n    };\n  }\n\n  if (!allowedTypes.includes(file.type)) {\n    return {\n      isValid: false,\n      error: \"File type not allowed\",\n    };\n  }\n\n  return { isValid: true };\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/i18n.ts",
      "target": "lib/i18n.ts",
      "content": "/**\n * Internationalization (i18n) support for the table library\n */\n\nexport interface TableTranslations {\n  // Pagination\n  pagination: {\n    previous: string;\n    next: string;\n    first: string;\n    last: string;\n    page: string;\n    of: string;\n    rowsPerPage: string;\n    goToPage: string;\n    totalRecords: string;\n    showingXtoYofZ: string; // \"Showing {from} to {to} of {total} entries\"\n    noData: string;\n  };\n\n  // Filters\n  filters: {\n    search: string;\n    searchAllColumns: string;\n    showFilter: string;\n    hideFilter: string;\n    clearFilter: string;\n    clearAllFilters: string;\n    filterBy: string;\n    all: string;\n    true: string;\n    false: string;\n    min: string;\n    max: string;\n    from: string;\n    to: string;\n    selectOption: string;\n    noOptionsFound: string;\n  };\n\n  // Sorting\n  sorting: {\n    sortAscending: string;\n    sortDescending: string;\n    clearSort: string;\n    sortBy: string;\n  };\n\n  // Column management\n  columns: {\n    hide: string;\n    show: string;\n    toggleVisibility: string;\n    resetColumns: string;\n    reorderColumns: string;\n    resizeColumn: string;\n  };\n\n  // Row selection\n  selection: {\n    selectAll: string;\n    selectRow: string;\n    deselectAll: string;\n    selectedCount: string; // \"{count} selected\"\n    selectAllOnPage: string;\n    selectAllRows: string;\n  };\n\n  // Loading and errors\n  status: {\n    loading: string;\n    error: string;\n    noResults: string;\n    retry: string;\n    loadMore: string;\n  };\n\n  // Security\n  security: {\n    rateLimitExceeded: string;\n    invalidInput: string;\n    fileSizeExceeded: string;\n    fileTypeNotAllowed: string;\n    inputTooLong: string;\n  };\n\n  // Accessibility\n  accessibility: {\n    sortColumn: string;\n    filterColumn: string;\n    selectAllRows: string;\n    selectRow: string;\n    columnHeader: string;\n    tableCaption: string;\n    resizeHandle: string;\n    dragHandle: string;\n  };\n}\n\n// Default English translations\nexport const defaultTranslations: TableTranslations = {\n  pagination: {\n    previous: \"Previous\",\n    next: \"Next\",\n    first: \"First\",\n    last: \"Last\",\n    page: \"Page\",\n    of: \"of\",\n    rowsPerPage: \"Rows per page\",\n    goToPage: \"Go to page\",\n    totalRecords: \"Total: {total} records\",\n    showingXtoYofZ: \"Showing {from} to {to} of {total} entries\",\n    noData: \"No data available\",\n  },\n\n  filters: {\n    search: \"Search\",\n    searchAllColumns: \"Search all columns...\",\n    showFilter: \"Show Filter\",\n    hideFilter: \"Hide Filter\",\n    clearFilter: \"Clear filter\",\n    clearAllFilters: \"Clear all filters\",\n    filterBy: \"Filter by {column}\",\n    all: \"All\",\n    true: \"True\",\n    false: \"False\",\n    min: \"Min\",\n    max: \"Max\",\n    from: \"From\",\n    to: \"To\",\n    selectOption: \"Select option\",\n    noOptionsFound: \"No options found\",\n  },\n\n  sorting: {\n    sortAscending: \"Sort ascending\",\n    sortDescending: \"Sort descending\",\n    clearSort: \"Clear sort\",\n    sortBy: \"Sort by {column}\",\n  },\n\n  columns: {\n    hide: \"Hide\",\n    show: \"Show\",\n    toggleVisibility: \"Toggle column visibility\",\n    resetColumns: \"Reset columns\",\n    reorderColumns: \"Reorder columns\",\n    resizeColumn: \"Resize column\",\n  },\n\n  selection: {\n    selectAll: \"Select all\",\n    selectRow: \"Select row\",\n    deselectAll: \"Deselect all\",\n    selectedCount: \"{count} selected\",\n    selectAllOnPage: \"Select all on this page\",\n    selectAllRows: \"Select all rows\",\n  },\n\n  status: {\n    loading: \"Loading...\",\n    error: \"An error occurred\",\n    noResults: \"No results found\",\n    retry: \"Retry\",\n    loadMore: \"Load more\",\n  },\n\n  security: {\n    rateLimitExceeded: \"Rate limit exceeded. Please try again later.\",\n    invalidInput: \"Invalid input detected\",\n    fileSizeExceeded: \"File size exceeds limit\",\n    fileTypeNotAllowed: \"File type not allowed\",\n    inputTooLong: \"Input is too long\",\n  },\n\n  accessibility: {\n    sortColumn: \"Sort column {column}\",\n    filterColumn: \"Filter column {column}\",\n    selectAllRows: \"Select all rows\",\n    selectRow: \"Select row {row}\",\n    columnHeader: \"Column header {column}\",\n    tableCaption: \"Data table with {rows} rows and {columns} columns\",\n    resizeHandle: \"Resize column {column}\",\n    dragHandle: \"Drag to reorder column {column}\",\n  },\n};\n\n// Turkish translations\nexport const turkishTranslations: TableTranslations = {\n  pagination: {\n    previous: \"Önceki\",\n    next: \"Sonraki\",\n    first: \"İlk\",\n    last: \"Son\",\n    page: \"Sayfa\",\n    of: \"/\",\n    rowsPerPage: \"Sayfa başına satır\",\n    goToPage: \"Sayfaya git\",\n    totalRecords: \"Toplam: {total} kayıt\",\n    showingXtoYofZ: \"{total} kayıttan {from}-{to} arası gösteriliyor\",\n    noData: \"Veri bulunamadı\",\n  },\n\n  filters: {\n    search: \"Ara\",\n    searchAllColumns: \"Tüm sütunlarda ara...\",\n    showFilter: \"Filtreyi Göster\",\n    hideFilter: \"Filtreyi Gizle\",\n    clearFilter: \"Filtreyi temizle\",\n    clearAllFilters: \"Tüm filtreleri temizle\",\n    filterBy: \"{column} sütununa göre filtrele\",\n    all: \"Tümü\",\n    true: \"Doğru\",\n    false: \"Yanlış\",\n    min: \"Min\",\n    max: \"Maks\",\n    from: \"Başlangıç\",\n    to: \"Bitiş\",\n    selectOption: \"Seçenek seçin\",\n    noOptionsFound: \"Seçenek bulunamadı\",\n  },\n\n  sorting: {\n    sortAscending: \"Artan sıralama\",\n    sortDescending: \"Azalan sıralama\",\n    clearSort: \"Sıralamayı temizle\",\n    sortBy: \"{column} sütununa göre sırala\",\n  },\n\n  columns: {\n    hide: \"Gizle\",\n    show: \"Göster\",\n    toggleVisibility: \"Sütun görünürlüğünü değiştir\",\n    resetColumns: \"Sütunları sıfırla\",\n    reorderColumns: \"Sütunları yeniden sırala\",\n    resizeColumn: \"Sütun boyutunu değiştir\",\n  },\n\n  selection: {\n    selectAll: \"Tümünü seç\",\n    selectRow: \"Satırı seç\",\n    deselectAll: \"Seçimi kaldır\",\n    selectedCount: \"{count} seçildi\",\n    selectAllOnPage: \"Bu sayfadakilerin tümünü seç\",\n    selectAllRows: \"Tüm satırları seç\",\n  },\n\n  status: {\n    loading: \"Yükleniyor...\",\n    error: \"Bir hata oluştu\",\n    noResults: \"Sonuç bulunamadı\",\n    retry: \"Tekrar dene\",\n    loadMore: \"Daha fazla yükle\",\n  },\n\n  security: {\n    rateLimitExceeded: \"İstek sınırı aşıldı. Lütfen daha sonra tekrar deneyin.\",\n    invalidInput: \"Geçersiz girdi tespit edildi\",\n    fileSizeExceeded: \"Dosya boyutu sınırı aşıldı\",\n    fileTypeNotAllowed: \"Dosya türüne izin verilmiyor\",\n    inputTooLong: \"Girdi çok uzun\",\n  },\n\n  accessibility: {\n    sortColumn: \"{column} sütununu sırala\",\n    filterColumn: \"{column} sütununu filtrele\",\n    selectAllRows: \"Tüm satırları seç\",\n    selectRow: \"{row} satırını seç\",\n    columnHeader: \"{column} sütun başlığı\",\n    tableCaption: \"{rows} satır ve {columns} sütunlu veri tablosu\",\n    resizeHandle: \"{column} sütununu yeniden boyutlandır\",\n    dragHandle: \"{column} sütununu yeniden sıralamak için sürükle\",\n  },\n};\n\n// Spanish translations\nexport const spanishTranslations: TableTranslations = {\n  pagination: {\n    previous: \"Anterior\",\n    next: \"Siguiente\",\n    first: \"Primero\",\n    last: \"Último\",\n    page: \"Página\",\n    of: \"de\",\n    rowsPerPage: \"Filas por página\",\n    goToPage: \"Ir a la página\",\n    totalRecords: \"Total: {total} registros\",\n    showingXtoYofZ: \"Mostrando {from} a {to} de {total} entradas\",\n    noData: \"No hay datos disponibles\",\n  },\n\n  filters: {\n    search: \"Buscar\",\n    searchAllColumns: \"Buscar en todas las columnas...\",\n    showFilter: \"Mostrar Filtro\",\n    hideFilter: \"Ocultar Filtro\",\n    clearFilter: \"Limpiar filtro\",\n    clearAllFilters: \"Limpiar todos los filtros\",\n    filterBy: \"Filtrar por {column}\",\n    all: \"Todos\",\n    true: \"Verdadero\",\n    false: \"Falso\",\n    min: \"Mín\",\n    max: \"Máx\",\n    from: \"Desde\",\n    to: \"Hasta\",\n    selectOption: \"Seleccionar opción\",\n    noOptionsFound: \"No se encontraron opciones\",\n  },\n\n  sorting: {\n    sortAscending: \"Ordenar ascendente\",\n    sortDescending: \"Ordenar descendente\",\n    clearSort: \"Limpiar ordenación\",\n    sortBy: \"Ordenar por {column}\",\n  },\n\n  columns: {\n    hide: \"Ocultar\",\n    show: \"Mostrar\",\n    toggleVisibility: \"Alternar visibilidad de columna\",\n    resetColumns: \"Restablecer columnas\",\n    reorderColumns: \"Reordenar columnas\",\n    resizeColumn: \"Redimensionar columna\",\n  },\n\n  selection: {\n    selectAll: \"Seleccionar todo\",\n    selectRow: \"Seleccionar fila\",\n    deselectAll: \"Deseleccionar todo\",\n    selectedCount: \"{count} seleccionados\",\n    selectAllOnPage: \"Seleccionar todos en esta página\",\n    selectAllRows: \"Seleccionar todas las filas\",\n  },\n\n  status: {\n    loading: \"Cargando...\",\n    error: \"Ocurrió un error\",\n    noResults: \"No se encontraron resultados\",\n    retry: \"Reintentar\",\n    loadMore: \"Cargar más\",\n  },\n\n  security: {\n    rateLimitExceeded:\n      \"Límite de velocidad excedido. Inténtelo de nuevo más tarde.\",\n    invalidInput: \"Entrada inválida detectada\",\n    fileSizeExceeded: \"El tamaño del archivo excede el límite\",\n    fileTypeNotAllowed: \"Tipo de archivo no permitido\",\n    inputTooLong: \"La entrada es demasiado larga\",\n  },\n\n  accessibility: {\n    sortColumn: \"Ordenar columna {column}\",\n    filterColumn: \"Filtrar columna {column}\",\n    selectAllRows: \"Seleccionar todas las filas\",\n    selectRow: \"Seleccionar fila {row}\",\n    columnHeader: \"Encabezado de columna {column}\",\n    tableCaption: \"Tabla de datos con {rows} filas y {columns} columnas\",\n    resizeHandle: \"Redimensionar columna {column}\",\n    dragHandle: \"Arrastrar para reordenar columna {column}\",\n  },\n};\n\n// French translations\nexport const frenchTranslations: TableTranslations = {\n  pagination: {\n    previous: \"Précédent\",\n    next: \"Suivant\",\n    first: \"Premier\",\n    last: \"Dernier\",\n    page: \"Page\",\n    of: \"sur\",\n    rowsPerPage: \"Lignes par page\",\n    goToPage: \"Aller à la page\",\n    totalRecords: \"Total : {total} enregistrements\",\n    showingXtoYofZ: \"Affichage de {from} à {to} sur {total} entrées\",\n    noData: \"Aucune donnée disponible\",\n  },\n\n  filters: {\n    search: \"Rechercher\",\n    searchAllColumns: \"Rechercher dans toutes les colonnes...\",\n    showFilter: \"Afficher le filtre\",\n    hideFilter: \"Masquer le filtre\",\n    clearFilter: \"Effacer le filtre\",\n    clearAllFilters: \"Effacer tous les filtres\",\n    filterBy: \"Filtrer par {column}\",\n    all: \"Tous\",\n    true: \"Vrai\",\n    false: \"Faux\",\n    min: \"Min\",\n    max: \"Max\",\n    from: \"De\",\n    to: \"À\",\n    selectOption: \"Sélectionner une option\",\n    noOptionsFound: \"Aucune option trouvée\",\n  },\n\n  sorting: {\n    sortAscending: \"Tri croissant\",\n    sortDescending: \"Tri décroissant\",\n    clearSort: \"Effacer le tri\",\n    sortBy: \"Trier par {column}\",\n  },\n\n  columns: {\n    hide: \"Masquer\",\n    show: \"Afficher\",\n    toggleVisibility: \"Basculer la visibilité de la colonne\",\n    resetColumns: \"Réinitialiser les colonnes\",\n    reorderColumns: \"Réorganiser les colonnes\",\n    resizeColumn: \"Redimensionner la colonne\",\n  },\n\n  selection: {\n    selectAll: \"Tout sélectionner\",\n    selectRow: \"Sélectionner la ligne\",\n    deselectAll: \"Tout désélectionner\",\n    selectedCount: \"{count} sélectionnés\",\n    selectAllOnPage: \"Sélectionner tout sur cette page\",\n    selectAllRows: \"Sélectionner toutes les lignes\",\n  },\n\n  status: {\n    loading: \"Chargement...\",\n    error: \"Une erreur s'est produite\",\n    noResults: \"Aucun résultat trouvé\",\n    retry: \"Réessayer\",\n    loadMore: \"Charger plus\",\n  },\n\n  security: {\n    rateLimitExceeded:\n      \"Limite de débit dépassée. Veuillez réessayer plus tard.\",\n    invalidInput: \"Entrée invalide détectée\",\n    fileSizeExceeded: \"La taille du fichier dépasse la limite\",\n    fileTypeNotAllowed: \"Type de fichier non autorisé\",\n    inputTooLong: \"L'entrée est trop longue\",\n  },\n\n  accessibility: {\n    sortColumn: \"Trier la colonne {column}\",\n    filterColumn: \"Filtrer la colonne {column}\",\n    selectAllRows: \"Sélectionner toutes les lignes\",\n    selectRow: \"Sélectionner la ligne {row}\",\n    columnHeader: \"En-tête de colonne {column}\",\n    tableCaption: \"Tableau de données avec {rows} lignes et {columns} colonnes\",\n    resizeHandle: \"Redimensionner la colonne {column}\",\n    dragHandle: \"Glisser pour réorganiser la colonne {column}\",\n  },\n};\n\n// German translations\nexport const germanTranslations: TableTranslations = {\n  pagination: {\n    previous: \"Zurück\",\n    next: \"Weiter\",\n    first: \"Erste\",\n    last: \"Letzte\",\n    page: \"Seite\",\n    of: \"von\",\n    rowsPerPage: \"Zeilen pro Seite\",\n    goToPage: \"Gehe zu Seite\",\n    totalRecords: \"Gesamt: {total} Datensätze\",\n    showingXtoYofZ: \"Zeige {from} bis {to} von {total} Einträgen\",\n    noData: \"Keine Daten verfügbar\",\n  },\n\n  filters: {\n    search: \"Suchen\",\n    searchAllColumns: \"In allen Spalten suchen...\",\n    showFilter: \"Filter anzeigen\",\n    hideFilter: \"Filter ausblenden\",\n    clearFilter: \"Filter löschen\",\n    clearAllFilters: \"Alle Filter löschen\",\n    filterBy: \"Nach {column} filtern\",\n    all: \"Alle\",\n    true: \"Wahr\",\n    false: \"Falsch\",\n    min: \"Min\",\n    max: \"Max\",\n    from: \"Von\",\n    to: \"Bis\",\n    selectOption: \"Option auswählen\",\n    noOptionsFound: \"Keine Optionen gefunden\",\n  },\n\n  sorting: {\n    sortAscending: \"Aufsteigend sortieren\",\n    sortDescending: \"Absteigend sortieren\",\n    clearSort: \"Sortierung löschen\",\n    sortBy: \"Nach {column} sortieren\",\n  },\n\n  columns: {\n    hide: \"Ausblenden\",\n    show: \"Anzeigen\",\n    toggleVisibility: \"Spaltensichtbarkeit umschalten\",\n    resetColumns: \"Spalten zurücksetzen\",\n    reorderColumns: \"Spalten neu anordnen\",\n    resizeColumn: \"Spaltengröße ändern\",\n  },\n\n  selection: {\n    selectAll: \"Alle auswählen\",\n    selectRow: \"Zeile auswählen\",\n    deselectAll: \"Auswahl aufheben\",\n    selectedCount: \"{count} ausgewählt\",\n    selectAllOnPage: \"Alle auf dieser Seite auswählen\",\n    selectAllRows: \"Alle Zeilen auswählen\",\n  },\n\n  status: {\n    loading: \"Laden...\",\n    error: \"Ein Fehler ist aufgetreten\",\n    noResults: \"Keine Ergebnisse gefunden\",\n    retry: \"Wiederholen\",\n    loadMore: \"Mehr laden\",\n  },\n\n  security: {\n    rateLimitExceeded:\n      \"Ratenlimit überschritten. Bitte versuchen Sie es später erneut.\",\n    invalidInput: \"Ungültige Eingabe erkannt\",\n    fileSizeExceeded: \"Dateigröße überschreitet das Limit\",\n    fileTypeNotAllowed: \"Dateityp nicht erlaubt\",\n    inputTooLong: \"Eingabe ist zu lang\",\n  },\n\n  accessibility: {\n    sortColumn: \"Spalte {column} sortieren\",\n    filterColumn: \"Spalte {column} filtern\",\n    selectAllRows: \"Alle Zeilen auswählen\",\n    selectRow: \"Zeile {row} auswählen\",\n    columnHeader: \"Spaltenüberschrift {column}\",\n    tableCaption: \"Datentabelle mit {rows} Zeilen und {columns} Spalten\",\n    resizeHandle: \"Spalte {column} in der Größe ändern\",\n    dragHandle: \"Ziehen, um Spalte {column} neu anzuordnen\",\n  },\n};\n\n// Available languages\nexport const availableLanguages = {\n  en: { name: \"English\", translations: defaultTranslations },\n  tr: { name: \"Türkçe\", translations: turkishTranslations },\n  es: { name: \"Español\", translations: spanishTranslations },\n  fr: { name: \"Français\", translations: frenchTranslations },\n  de: { name: \"Deutsch\", translations: germanTranslations },\n} as const;\n\nexport type SupportedLanguage = keyof typeof availableLanguages;\n\n/**\n * Simple template string replacement\n */\nexport function interpolate(\n  template: string,\n  values: Record<string, string | number>\n): string {\n  return template.replace(/\\{(\\w+)\\}/g, (match, key) => {\n    return values[key]?.toString() || match;\n  });\n}\n\n/**\n * Get translation with interpolation support\n */\nexport function t(\n  translations: TableTranslations,\n  path: string,\n  values?: Record<string, string | number>\n): string {\n  const keys = path.split(\".\");\n  let result: any = translations;\n\n  for (const key of keys) {\n    result = result?.[key];\n    if (result === undefined) {\n      console.warn(`Translation key not found: ${path}`);\n      return path;\n    }\n  }\n\n  if (typeof result !== \"string\") {\n    console.warn(`Translation value is not a string: ${path}`);\n    return path;\n  }\n\n  return values ? interpolate(result, values) : result;\n}\n\n/**\n * Create a translation function bound to specific translations\n */\nexport function createTranslator(translations: TableTranslations) {\n  return (path: string, values?: Record<string, string | number>) =>\n    t(translations, path, values);\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "types/types.ts",
      "target": "types/types.ts",
      "content": "import {\n  ColumnDef as TSColumnDef,\n  Column as TSColumn,\n  GroupColumnDef as TSGroupColumnDef,\n  DeepKeys,\n  CellContext,\n  ColumnFiltersState,\n  PaginationState,\n  ColumnSizingState,\n} from \"@tanstack/react-table\";\nimport { TableTranslations } from \"../lib/i18n\";\n\nexport type TableOptions<T> = {\n  data: T[];\n  columns: ColumnDef<T>[];\n  globalFilter?: GlobalFilterType;\n  filterRowClassName?: string;\n  rowClassName?: string;\n  colClassName?: string;\n  filter?: boolean;\n  reorderable?: boolean;\n  showFilterButton?: boolean;\n  pagination?: PaginationOptions;\n\n  // Column sizing options\n  enableColumnResizing?: boolean;\n  columnResizeMode?: \"onChange\" | \"onEnd\";\n  columnResizeDirection?: \"ltr\" | \"rtl\";\n  fillTableWidth?: boolean;\n\n  // Internationalization\n  translations?: TableTranslations;\n} & Lazy &\n  Sorting &\n  ColumnFilters &\n  Pagination &\n  ColumnVisibility &\n  ColumnOrder &\n  RowSelection &\n  ColumnSizing &\n  ShowFilter;\n\ntype ColumnVisibility =\n  | {\n      columnVisibility?: Record<string, boolean>;\n      onColumnVisibilityChange?: (visibility: Record<string, boolean>) => void;\n    }\n  | {\n      columnVisibility?: never;\n      onColumnVisibilityChange?: never;\n    };\n\ntype Pagination =\n  | {\n      paginationState?: PaginationState;\n      onPaginationChange?: (pagination: PaginationState) => void;\n    }\n  | {\n      paginationState?: never;\n      onPaginationChange?: never;\n    };\n\ntype ColumnFilters =\n  | {\n      columnFilters?: ColumnFiltersState;\n      onColumnFiltersChange?: (filters: ColumnFiltersState) => void;\n    }\n  | {\n      columnFilters?: never;\n      onColumnFiltersChange?: never;\n    };\n\ntype Sorting =\n  | {\n      sorting?: SortingState[];\n      onSortingChange?: (sorting: SortingState[]) => void;\n    }\n  | {\n      sorting?: never;\n      onSortingChange?: never;\n    };\n\ntype Lazy =\n  | {\n      lazy: true;\n      onLazyLoad: (event: LazyLoadEvent) => void;\n    }\n  | {\n      lazy?: false;\n      onLazyLoad?: never;\n    };\n\ntype ColumnOrder =\n  | {\n      columnOrder?: string[];\n      onColumnOrderChange?: (order: string[]) => void;\n    }\n  | {\n      columnOrder?: never;\n      onColumnOrderChange?: never;\n    };\n\ntype RowSelection =\n  | {\n      rowSelection?: Record<string, boolean>;\n      onRowSelectionChange?: (selection: Record<string, boolean>) => void;\n      enableRowSelectionFn?: (row: any) => boolean;\n    }\n  | {\n      rowSelection?: never;\n      onRowSelectionChange?: never;\n      enableRowSelectionFn?: never;\n    };\n\ntype ShowFilter =\n  | {\n      showFilter?: boolean;\n      onShowFilterChange?: (show: boolean) => void;\n    }\n  | {\n      showFilter?: never;\n      onShowFilterChange?: never;\n    };\n\ntype GlobalFilterType = {\n  show?: boolean;\n  globalFilter?: string;\n  onGlobalFilterChange?: (filter: string) => void;\n};\n\ntype ColumnSizing =\n  | {\n      columnSizing?: ColumnSizingState;\n      onColumnSizingChange?: (sizing: ColumnSizingState) => void;\n      defaultColumn?: {\n        size?: number;\n        minSize?: number;\n        maxSize?: number;\n      };\n    }\n  | {\n      columnSizing?: never;\n      onColumnSizingChange?: never;\n      defaultColumn?: never;\n    };\n\nexport type ColumnDef<T> = {\n  filter?: FilterType<T>;\n  cell?: (info: CellContext<T, unknown>) => any;\n  sortField?: string;\n  className?: string;\n  headerClassName?: string;\n  footerClassName?: string;\n  reorderable?: boolean;\n\n  // Column sizing properties\n  size?: number;\n  minSize?: number;\n  maxSize?: number;\n  enableResizing?: boolean;\n} & (\n  | (\n      | {\n          accessorFn: (row: T) => any;\n          id: string;\n          accessorKey?: never;\n          columns?: never;\n        }\n      | {\n          accessorKey: DeepKeys<T>;\n          accessorFn?: never;\n          id?: string;\n          columns?: never;\n        }\n    )\n  | {\n      columns: ColumnDef<T>[];\n      accessorFn?: never;\n      accessorKey?: never;\n      id?: string;\n    }\n) &\n  TSColumnDef<T, unknown>;\n\nexport type Column<T> = {\n  columnDef: ColumnDef<T>;\n} & TSColumn<T, unknown>;\n\nexport type GroupColumnDef<T> = {\n  columns?: ColumnDef<T>[];\n} & TSGroupColumnDef<T, unknown>;\n\nexport type FilterType<T> = {\n  field: string;\n  className?: string;\n} & (\n  | {\n      type: \"text\";\n      placeholder: string;\n      showList?: boolean;\n      showTotal?: boolean;\n    }\n  | {\n      type: \"range\";\n      minPlaceholder?: string;\n      maxPlaceholder?: string;\n      showLimit?: boolean;\n      minLimit?: number | \"faceted\";\n      maxLimit?: number | \"faceted\";\n    }\n  | {\n      type: \"select\" | \"multi-select\";\n      options: any[];\n      optionLabel: string;\n      optionValue: string;\n      allLabel?: string;\n    }\n  | {\n      type: \"boolean\";\n      trueLabel?: string;\n      falseLabel?: string;\n      allLabel?: string;\n    }\n  | {\n      type: \"date\";\n    }\n  | {\n      type: \"date-range\";\n    }\n  | {\n      type: \"custom\";\n      component: React.ComponentType<{ column: Column<T> }>;\n    }\n);\n\nexport type PaginationOptions = {\n  pageSizeOptions?: number[];\n  pageSize: number;\n  totalRecords: number;\n  mode?: \"advanced\" | \"default\" | \"compact\";\n  maxVisiblePages?: number;\n  goToPageLabel?: string;\n  pageSizeLabel?: string;\n  className?: string;\n  totalLabel?: string;\n  layout?: (\"total\" | \"pageSize\" | \"goto\" | \"buttons\")[];\n};\n\nexport type LazyLoadEvent = {\n  first: number;\n  rows: number;\n  filters: ColumnFiltersState;\n  globalFilter: string;\n  sorting: SortingState[];\n  page: number;\n};\n\nexport type SortingState = {\n  id: string;\n  desc: boolean;\n};\n",
      "type": "registry:file"
    }
  ],
  "tailwind": {
    "config": {
      "theme": {
        "extend": {}
      }
    }
  }
}