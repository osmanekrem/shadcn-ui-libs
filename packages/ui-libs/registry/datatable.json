{
  "$schema": "https://ui.shadcn.com/schema.json",
  "name": "datatable",
  "type": "registry:component",
  "description": "A powerful, feature-rich React table component built on top of TanStack Table v8",
  "registryDependencies": [
    "table",
    "button",
    "checkbox",
    "input",
    "select",
    "dropdown-menu"
  ],
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/match-sorter-utils",
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "lucide-react"
  ],
  "files": [
    {
      "path": "ui-elements/debounced-input.tsx",
      "target": "ui-elements/debounced-input.tsx",
      "content": "\"use client\";\n\nimport {\n  InputHTMLAttributes,\n  useEffect,\n  useState,\n  useRef,\n  useCallback,\n  useMemo,\n} from \"react\";\nimport { Input } from \"../components/ui/input\";\n// Tree-shakeable import - only imports sanitizeSearchInput\nimport { sanitizeSearchInput } from \"../lib/security/sanitize\";\n// Tree-shakeable import - only imports useDebounce\nimport { useDebounce } from \"../lib/hooks/use-debounce\";\n// Tree-shakeable import - only imports useRateLimit\nimport { useRateLimit } from \"../lib/hooks/use-rate-limit\";\n\nfunction DebouncedInput({\n  value: initialValue,\n  onChange,\n  debounce = 500,\n  type = \"text\",\n  maxLength = 1000,\n  ...props\n}: {\n  value: string | number | undefined;\n  onChange: (value: string | number | undefined) => void;\n  debounce?: number;\n} & Omit<InputHTMLAttributes<HTMLInputElement>, \"onChange\">) {\n  const [value, setValue] = useState(initialValue);\n  const checkRateLimit = useRateLimit();\n  const previousValueRef = useRef<string | number | undefined>(initialValue);\n\n  // Memoize onChange callback to prevent unnecessary re-renders\n  const onChangeRef = useRef(onChange);\n  useEffect(() => {\n    onChangeRef.current = onChange;\n  }, [onChange]);\n\n  // Sync external value changes\n  useEffect(() => {\n    if (type === \"number\") {\n      const numValue = Number(initialValue);\n      previousValueRef.current =\n        isNaN(numValue) || initialValue == null || initialValue === \"\"\n          ? undefined\n          : numValue;\n    } else {\n      previousValueRef.current = initialValue;\n    }\n    setValue(initialValue);\n  }, [initialValue, type]);\n\n  // Debounced callback with sanitization and rate limiting\n  const handleDebouncedValue = useCallback(\n    (debouncedValue: string | number | undefined) => {\n      // Rate limiting check\n      if (!checkRateLimit()) {\n        return;\n      }\n\n      let sanitizedValue: string | number | undefined = debouncedValue;\n\n      // Sanitize based on input type\n      if (type === \"text\" || type === \"search\") {\n        sanitizedValue =\n          typeof debouncedValue === \"string\"\n            ? sanitizeSearchInput(debouncedValue)\n            : String(debouncedValue);\n      } else if (type === \"number\") {\n        const numValue = Number(debouncedValue);\n        sanitizedValue =\n          isNaN(numValue) || debouncedValue == null || debouncedValue === \"\"\n            ? undefined\n            : Math.max(-1000000, Math.min(1000000, numValue));\n      }\n\n      // Only call onChange if the value has actually changed\n      if (sanitizedValue !== previousValueRef.current) {\n        previousValueRef.current = sanitizedValue;\n        onChangeRef.current(sanitizedValue);\n      }\n    },\n    [type, checkRateLimit]\n  );\n\n  // Use debounce hook\n  useDebounce(value, debounce, handleDebouncedValue);\n\n  // Memoize handler to prevent unnecessary re-renders\n  const handleInputChange = useCallback(\n    (e: React.ChangeEvent<HTMLInputElement>) => {\n      const inputValue = e.target.value;\n\n      // Basic length validation\n      if (inputValue.length > maxLength) {\n        return;\n      }\n\n      // Additional validation for specific input types\n      if (\n        type === \"number\" &&\n        inputValue !== \"\" &&\n        !/^-?\\d*\\.?\\d*$/.test(inputValue)\n      ) {\n        return;\n      }\n\n      setValue(inputValue);\n    },\n    [maxLength, type]\n  );\n\n  // Memoize autoComplete value\n  const autoCompleteValue = useMemo(\n    () => props.autoComplete || \"off\",\n    [props.autoComplete]\n  );\n\n  return (\n    <Input\n      {...props}\n      type={type}\n      maxLength={maxLength}\n      value={value}\n      onChange={handleInputChange}\n      autoComplete={autoCompleteValue}\n      spellCheck={false}\n    />\n  );\n}\n\nexport default DebouncedInput;\n",
      "type": "registry:file"
    },
    {
      "path": "lib/utils.ts",
      "target": "lib/utils.ts",
      "content": "import { GetFieldType } from \"./utils.types\";\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\n/**\n * Internal utility function to merge Tailwind CSS classes with clsx and tailwind-merge.\n * This ensures proper class merging and conflict resolution for Tailwind utilities.\n *\n * **Note:** This function is for internal use only and is not exported from the main package.\n * If you need a similar utility, use `clsx` and `tailwind-merge` directly.\n *\n * @param inputs - Variable number of class values (strings, objects, arrays, etc.)\n * @returns Merged class string with Tailwind conflicts resolved\n *\n * @internal\n */\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n/**\n * Safely retrieves a nested value from an object using a dot-notation path string.\n * Supports nested objects, arrays, and optional default values.\n *\n * @template TData - The type of the data object\n * @template TPath - The path string type (e.g., \"user.name\" or \"items[0].id\")\n * @template TDefault - The type of the default value (optional)\n *\n * @param data - The data object to extract the value from\n * @param path - Dot-notation path string (e.g., \"user.profile.name\" or \"items[0].id\")\n * @param defaultValue - Optional default value to return if the path doesn't exist\n * @returns The value at the specified path, or the default value if not found\n *\n * @example\n * ```tsx\n * import { getValue } from \"tanstack-shadcn-table\";\n *\n * const user = {\n *   name: \"John\",\n *   profile: {\n *     email: \"john@example.com\",\n *   },\n *   items: [{ id: 1 }, { id: 2 }],\n * };\n *\n * // Get nested value\n * const email = getValue(user, \"profile.email\"); // \"john@example.com\"\n *\n * // Get array value\n * const firstItemId = getValue(user, \"items[0].id\"); // 1\n *\n * // With default value\n * const phone = getValue(user, \"profile.phone\", \"N/A\"); // \"N/A\"\n * ```\n */\nexport function getValue<\n  TData,\n  TPath extends string,\n  TDefault = GetFieldType<TData, TPath>,\n>(\n  data: TData,\n  path: TPath,\n  defaultValue?: TDefault\n): GetFieldType<TData, TPath> | TDefault {\n  const value = path\n    .split(/[.[\\]]/)\n    .filter(Boolean)\n    .reduce<GetFieldType<TData, TPath>>(\n      (value, key) => (value as any)?.[key],\n      data as any\n    );\n\n  return value !== undefined ? value : (defaultValue as TDefault);\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/utils.types.ts",
      "target": "lib/utils.types.ts",
      "content": "type DepthCounter = [never, 1, 2, 3, 4, 5, 6];\n\nexport type DeepKeys<\n  T,\n  Prefix extends string = \"\",\n  Depth extends number = 6,\n> = [Depth] extends [never]\n  ? never\n  : T extends object\n    ? {\n        [K in keyof T]-?: K extends string\n          ?\n              | `${Prefix}${Prefix extends \"\" ? \"\" : \".\"}${K}`\n              | DeepKeys<\n                  T[K],\n                  `${Prefix}${Prefix extends \"\" ? \"\" : \".\"}${K}`,\n                  Prev<Depth>\n                >\n          : never;\n      }[keyof T]\n    : \"\";\n\ntype Prev<N extends number> = DepthCounter[N];\n\ntype FieldWithPossiblyUndefined<T, key> =\n  | GetFieldType<Exclude<T, undefined>, key>\n  | Extract<T, undefined>;\n\ntype GetIndexedField<T, K> = K extends keyof T\n  ? T[K]\n  : K extends `${number}`\n    ? \"0\" extends keyof T\n      ? undefined\n      : number extends keyof T\n        ? T[number]\n        : undefined\n    : undefined;\n\nexport type GetFieldType<T, P> = P extends `${infer Left}.${infer Right}`\n  ? Left extends keyof T\n    ? FieldWithPossiblyUndefined<T[Left], Right>\n    : Left extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ? FieldWithPossiblyUndefined<\n            | GetIndexedField<Exclude<T[FieldKey], undefined>, IndexKey>\n            | Extract<T[FieldKey], undefined>,\n            Right\n          >\n        : undefined\n      : undefined\n  : P extends keyof T\n    ? T[P]\n    : P extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ?\n            | GetIndexedField<Exclude<T[FieldKey], undefined>, IndexKey>\n            | Extract<T[FieldKey], undefined>\n        : undefined\n      : undefined;\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/security.ts",
      "target": "lib/security.ts",
      "content": "/**\n * Security utilities - Backward compatibility export\n * \n * @deprecated Use tree-shakeable imports instead:\n * \n * @example\n * // ✅ Tree-shakeable - only imports sanitizeSearchInput\n * import { sanitizeSearchInput } from 'tanstack-shadcn-table/lib/security/sanitize';\n * \n * // ❌ Imports all security utilities (not tree-shakeable)\n * import { sanitizeSearchInput } from 'tanstack-shadcn-table/lib/security';\n * \n * For backward compatibility, this file re-exports from the modular structure.\n */\n\n// Re-export from modular structure for backward compatibility\nexport { sanitizeHtml, sanitizeSearchInput, sanitizeFilterValue } from './security/sanitize';\nexport { validatePaginationParams, validateSortingParams, validateFileUpload } from './security/validation';\nexport { RateLimiter } from './security/rate-limiter';\nexport { CSP_DIRECTIVES } from './security/csp';\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/i18n/index.ts",
      "target": "lib/i18n/index.ts",
      "content": "/**\n * Main i18n exports\n * \n * For tree-shaking, import translations directly from locales:\n * \n * @example\n * ```ts\n * // ✅ Tree-shakeable - only imports English\n * import { defaultTranslations } from 'tanstack-shadcn-table/i18n/en';\n * \n * // ❌ Imports all languages\n * import { defaultTranslations } from 'tanstack-shadcn-table/lib/i18n';\n * ```\n */\n\n// Re-export types\nexport type { TableTranslations, SupportedLanguage } from \"./types\";\n\n// Re-export utilities\nexport { t, interpolate, createTranslator } from \"./utils\";\n\n// Re-export all locales (for convenience, but not tree-shakeable)\n// For tree-shaking, import directly from ./locales/{lang}\nexport {\n  defaultTranslations,\n  turkishTranslations,\n  spanishTranslations,\n  frenchTranslations,\n  germanTranslations,\n} from \"./locales\";\n\n// Available languages map (lazy-loaded for tree-shaking)\nimport { defaultTranslations } from \"./locales/en\";\nimport { turkishTranslations } from \"./locales/tr\";\nimport { spanishTranslations } from \"./locales/es\";\nimport { frenchTranslations } from \"./locales/fr\";\nimport { germanTranslations } from \"./locales/de\";\n\nexport const availableLanguages = {\n  en: { name: \"English\", translations: defaultTranslations },\n  tr: { name: \"Türkçe\", translations: turkishTranslations },\n  es: { name: \"Español\", translations: spanishTranslations },\n  fr: { name: \"Français\", translations: frenchTranslations },\n  de: { name: \"Deutsch\", translations: germanTranslations },\n} as const;\n\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/i18n/types.ts",
      "target": "lib/i18n/types.ts",
      "content": "/**\n * Internationalization (i18n) types for the table library\n */\n\nexport interface TableTranslations {\n  // Pagination\n  pagination: {\n    previous: string;\n    next: string;\n    first: string;\n    last: string;\n    page: string;\n    of: string;\n    rowsPerPage: string;\n    goToPage: string;\n    totalRecords: string;\n    showingXtoYofZ: string; // \"Showing {from} to {to} of {total} entries\"\n    noData: string;\n  };\n\n  // Filters\n  filters: {\n    search: string;\n    searchAllColumns: string;\n    showFilter: string;\n    hideFilter: string;\n    clearFilter: string;\n    clearAllFilters: string;\n    filterBy: string;\n    all: string;\n    true: string;\n    false: string;\n    min: string;\n    max: string;\n    from: string;\n    to: string;\n    selectOption: string;\n    noOptionsFound: string;\n    // Faceted filter\n    selectedCount: string; // \"{count} selected\"\n    clearFilters: string;\n    noResultsFound: string;\n  };\n\n  // Sorting\n  sorting: {\n    sortAscending: string;\n    sortDescending: string;\n    clearSort: string;\n    sortBy: string;\n  };\n\n  // Column management\n  columns: {\n    hide: string;\n    show: string;\n    toggleVisibility: string;\n    resetColumns: string;\n    reorderColumns: string;\n    resizeColumn: string;\n  };\n\n  // Row selection\n  selection: {\n    selectAll: string;\n    selectRow: string;\n    deselectAll: string;\n    selectedCount: string; // \"{count} selected\"\n    selectAllOnPage: string;\n    selectAllRows: string;\n  };\n\n  // Loading and errors\n  status: {\n    loading: string;\n    error: string;\n    noResults: string;\n    retry: string;\n    loadMore: string;\n  };\n\n  // Security\n  security: {\n    rateLimitExceeded: string;\n    invalidInput: string;\n    fileSizeExceeded: string;\n    fileTypeNotAllowed: string;\n    inputTooLong: string;\n  };\n\n  // Accessibility\n  accessibility: {\n    sortColumn: string;\n    filterColumn: string;\n    selectAllRows: string;\n    selectRow: string;\n    columnHeader: string;\n    tableCaption: string;\n    resizeHandle: string;\n    dragHandle: string;\n  };\n}\n\nexport type SupportedLanguage = \"en\" | \"tr\" | \"es\" | \"fr\" | \"de\";\n\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/i18n/utils.ts",
      "target": "lib/i18n/utils.ts",
      "content": "/**\n * Internationalization utility functions\n */\n\nimport type { TableTranslations } from \"./types\";\n\n/**\n * Simple template string replacement function.\n * Replaces placeholders in the format `{key}` with corresponding values.\n * \n * @param template - Template string with placeholders (e.g., \"Hello {name}!\")\n * @param values - Object with values to replace placeholders\n * @returns String with placeholders replaced by values\n * \n * @example\n * ```tsx\n * import { interpolate } from 'tanstack-shadcn-table';\n * \n * const message = interpolate(\"Hello {name}!\", { name: \"World\" });\n * // Result: \"Hello World!\"\n * \n * const total = interpolate(\"Total: {count} items\", { count: 42 });\n * // Result: \"Total: 42 items\"\n * ```\n * \n * @public\n */\nexport function interpolate(\n  template: string,\n  values: Record<string, string | number>\n): string {\n  return template.replace(/\\{(\\w+)\\}/g, (match, key) => {\n    return values[key]?.toString() || match;\n  });\n}\n\n/**\n * Gets a translation value from the translations object using a dot-notation path.\n * Supports nested objects and string interpolation.\n * \n * @param translations - The translations object to extract the value from\n * @param path - Dot-notation path to the translation key (e.g., \"pagination.next\")\n * @param values - Optional object with values for string interpolation\n * @returns The translated string with interpolated values, or the path if not found\n * \n * @example\n * ```tsx\n * import { t } from 'tanstack-shadcn-table';\n * import { turkishTranslations } from 'tanstack-shadcn-table/i18n/tr';\n * \n * // Simple translation\n * const next = t(turkishTranslations, \"pagination.next\");\n * // Result: \"Sonraki\"\n * \n * // Translation with interpolation\n * const total = t(turkishTranslations, \"pagination.totalRecords\", { total: 100 });\n * // Result: \"Toplam: 100 kayıt\"\n * ```\n * \n * @public\n */\nexport function t(\n  translations: TableTranslations,\n  path: string,\n  values?: Record<string, string | number>\n): string {\n  const keys = path.split(\".\");\n  let result: any = translations;\n\n  for (const key of keys) {\n    result = result?.[key];\n    if (result === undefined) {\n      console.warn(`Translation key not found: ${path}`);\n      return path;\n    }\n  }\n\n  if (typeof result !== \"string\") {\n    console.warn(`Translation value is not a string: ${path}`);\n    return path;\n  }\n\n  return values ? interpolate(result, values) : result;\n}\n\n/**\n * Creates a translation function bound to specific translations.\n * This is useful for creating a reusable translator function that doesn't require\n * passing the translations object every time.\n * \n * @param translations - The translations object to bind to the translator function\n * @returns A function that takes a path and optional values, returning the translated string\n * \n * @example\n * ```tsx\n * import { createTranslator } from 'tanstack-shadcn-table';\n * import { turkishTranslations } from 'tanstack-shadcn-table/i18n/tr';\n * \n * // Create a bound translator\n * const t = createTranslator(turkishTranslations);\n * \n * // Use the translator\n * const next = t(\"pagination.next\"); // \"Sonraki\"\n * const total = t(\"pagination.totalRecords\", { total: 100 }); // \"Toplam: 100 kayıt\"\n * ```\n * \n * @public\n */\nexport function createTranslator(translations: TableTranslations) {\n  return (path: string, values?: Record<string, string | number>) =>\n    t(translations, path, values);\n}\n\n",
      "type": "registry:lib"
    },
    {
      "path": "types/types.ts",
      "target": "types/types.ts",
      "content": "import {\n  ColumnDef as TSColumnDef,\n  Column as TSColumn,\n  GroupColumnDef as TSGroupColumnDef,\n  DeepKeys,\n  CellContext,\n  ColumnFiltersState,\n  PaginationState,\n  ColumnSizingState,\n} from \"@tanstack/react-table\";\nimport { TableTranslations } from \"../lib/i18n\";\n\n/**\n * Main configuration object for the DataTable component.\n * \n * @template T - The type of data in each row\n * \n * @example\n * ```tsx\n * const tableOptions: TableOptions<Person> = {\n *   data: people,\n *   columns: personColumns,\n *   pagination: {\n *     pageSize: 10,\n *     totalRecords: 100,\n *   },\n *   filter: true,\n *   globalFilter: {\n *     show: true,\n *   },\n * };\n * ```\n */\nexport type TableOptions<T> = {\n  data: T[];\n  columns: ColumnDef<T>[];\n  globalFilter?: GlobalFilterType;\n  filterRowClassName?: string;\n  rowClassName?: string;\n  colClassName?: string;\n  filter?: boolean;\n  reorderable?: boolean;\n  showFilterButton?: boolean;\n  pagination?: PaginationOptions;\n\n  // Column sizing options\n  enableColumnResizing?: boolean;\n  columnResizeMode?: \"onChange\" | \"onEnd\";\n  columnResizeDirection?: \"ltr\" | \"rtl\";\n  fillTableWidth?: boolean;\n\n  // Internationalization\n  translations?: TableTranslations;\n} & Lazy &\n  Sorting &\n  ColumnFilters &\n  Pagination &\n  ColumnVisibility &\n  ColumnOrder &\n  RowSelection &\n  ColumnSizing &\n  ShowFilter;\n\ntype ColumnVisibility =\n  | {\n      columnVisibility?: Record<string, boolean>;\n      onColumnVisibilityChange?: (visibility: Record<string, boolean>) => void;\n    }\n  | {\n      columnVisibility?: never;\n      onColumnVisibilityChange?: never;\n    };\n\ntype Pagination =\n  | {\n      paginationState?: PaginationState;\n      onPaginationChange?: (pagination: PaginationState) => void;\n    }\n  | {\n      paginationState?: never;\n      onPaginationChange?: never;\n    };\n\ntype ColumnFilters =\n  | {\n      columnFilters?: ColumnFiltersState;\n      onColumnFiltersChange?: (filters: ColumnFiltersState) => void;\n    }\n  | {\n      columnFilters?: never;\n      onColumnFiltersChange?: never;\n    };\n\ntype Sorting =\n  | {\n      sorting?: SortingState[];\n      onSortingChange?: (sorting: SortingState[]) => void;\n    }\n  | {\n      sorting?: never;\n      onSortingChange?: never;\n    };\n\ntype Lazy =\n  | {\n      lazy: true;\n      onLazyLoad: (event: LazyLoadEvent) => void;\n    }\n  | {\n      lazy?: false;\n      onLazyLoad?: never;\n    };\n\ntype ColumnOrder =\n  | {\n      columnOrder?: string[];\n      onColumnOrderChange?: (order: string[]) => void;\n    }\n  | {\n      columnOrder?: never;\n      onColumnOrderChange?: never;\n    };\n\ntype RowSelection =\n  | {\n      rowSelection?: Record<string, boolean>;\n      onRowSelectionChange?: (selection: Record<string, boolean>) => void;\n      enableRowSelectionFn?: (row: any) => boolean;\n    }\n  | {\n      rowSelection?: never;\n      onRowSelectionChange?: never;\n      enableRowSelectionFn?: never;\n    };\n\ntype ShowFilter =\n  | {\n      showFilter?: boolean;\n      onShowFilterChange?: (show: boolean) => void;\n    }\n  | {\n      showFilter?: never;\n      onShowFilterChange?: never;\n    };\n\ntype GlobalFilterType = {\n  show?: boolean;\n  globalFilter?: string;\n  onGlobalFilterChange?: (filter: string) => void;\n};\n\ntype ColumnSizing =\n  | {\n      columnSizing?: ColumnSizingState;\n      onColumnSizingChange?: (sizing: ColumnSizingState) => void;\n      defaultColumn?: {\n        size?: number;\n        minSize?: number;\n        maxSize?: number;\n      };\n    }\n  | {\n      columnSizing?: never;\n      onColumnSizingChange?: never;\n      defaultColumn?: never;\n    };\n\n/**\n * Column definition for DataTable.\n * Extends TanStack Table's ColumnDef with additional filter and styling options.\n * \n * @template T - The type of data in each row\n * \n * @example\n * ```tsx\n * const columns: ColumnDef<Person>[] = [\n *   {\n *     accessorKey: \"firstName\",\n *     header: \"First Name\",\n *     filter: {\n *       type: \"text\",\n *       field: \"firstName\",\n *       placeholder: \"Search...\",\n *     },\n *   },\n *   {\n *     accessorKey: \"age\",\n *     header: \"Age\",\n *     filter: {\n *       type: \"range\",\n *       field: \"age\",\n *     },\n *     size: 100,\n *     minSize: 50,\n *     maxSize: 200,\n *   },\n * ];\n * ```\n */\nexport type ColumnDef<T> = {\n  filter?: FilterType<T>;\n  cell?: (info: CellContext<T, unknown>) => any;\n  sortField?: string;\n  className?: string;\n  headerClassName?: string;\n  footerClassName?: string;\n  reorderable?: boolean;\n\n  // Column sizing properties\n  size?: number;\n  minSize?: number;\n  maxSize?: number;\n  enableResizing?: boolean;\n} & (\n  | (\n      | {\n          accessorFn: (row: T) => any;\n          id: string;\n          accessorKey?: never;\n          columns?: never;\n        }\n      | {\n          accessorKey: DeepKeys<T>;\n          accessorFn?: never;\n          id?: string;\n          columns?: never;\n        }\n    )\n  | {\n      columns: ColumnDef<T>[];\n      accessorFn?: never;\n      accessorKey?: never;\n      id?: string;\n    }\n) &\n  TSColumnDef<T, unknown>;\n\nexport type Column<T> = {\n  columnDef: ColumnDef<T>;\n} & TSColumn<T, unknown>;\n\nexport type GroupColumnDef<T> = {\n  columns?: ColumnDef<T>[];\n} & TSGroupColumnDef<T, unknown>;\n\n/**\n * Filter configuration for a column.\n * Supports multiple filter types: text, range, select, boolean, date, and custom.\n * \n * @template T - The type of data in each row\n * \n * @example\n * ```tsx\n * // Text filter\n * {\n *   type: \"text\",\n *   field: \"firstName\",\n *   placeholder: \"Search first name...\",\n * }\n * \n * // Range filter\n * {\n *   type: \"range\",\n *   field: \"age\",\n *   minPlaceholder: \"Min age\",\n *   maxPlaceholder: \"Max age\",\n * }\n * \n * // Select filter\n * {\n *   type: \"select\",\n *   field: \"status\",\n *   options: [\n *     { label: \"Active\", value: \"active\" },\n *     { label: \"Inactive\", value: \"inactive\" },\n *   ],\n *   optionLabel: \"label\",\n *   optionValue: \"value\",\n * }\n * ```\n */\nexport type FilterType<T> = {\n  field: string;\n  className?: string;\n} & (\n  | {\n      type: \"text\";\n      placeholder: string;\n      showList?: boolean;\n      showTotal?: boolean;\n    }\n  | {\n      type: \"range\";\n      minPlaceholder?: string;\n      maxPlaceholder?: string;\n      showLimit?: boolean;\n      minLimit?: number | \"faceted\";\n      maxLimit?: number | \"faceted\";\n    }\n  | {\n      type: \"select\" | \"multi-select\";\n      options: any[];\n      optionLabel: string;\n      optionValue: string;\n      allLabel?: string;\n    }\n  | {\n      type: \"boolean\";\n      trueLabel?: string;\n      falseLabel?: string;\n      allLabel?: string;\n    }\n  | {\n      type: \"date\";\n    }\n  | {\n      type: \"date-range\";\n    }\n  | {\n      type: \"custom\";\n      component: React.ComponentType<{ column: Column<T> }>;\n    }\n);\n\n/**\n * Pagination configuration options.\n * \n * @example\n * ```tsx\n * const pagination: PaginationOptions = {\n *   pageSize: 10,\n *   totalRecords: 100,\n *   pageSizeOptions: [5, 10, 20, 50],\n *   mode: \"advanced\",\n *   layout: [\"total\", \"pageSize\", \"goto\", \"buttons\"],\n * };\n * ```\n */\nexport type PaginationOptions = {\n  pageSizeOptions?: number[];\n  pageSize: number;\n  totalRecords: number;\n  mode?: \"advanced\" | \"default\" | \"compact\";\n  maxVisiblePages?: number;\n  goToPageLabel?: string;\n  pageSizeLabel?: string;\n  className?: string;\n  totalLabel?: string;\n  layout?: (\"total\" | \"pageSize\" | \"goto\" | \"buttons\")[];\n};\n\n/**\n * Event object passed to the onLazyLoad callback when lazy loading is enabled.\n * Contains all the necessary information to fetch data from the server.\n * \n * @example\n * ```tsx\n * const handleLazyLoad = async (event: LazyLoadEvent) => {\n *   const response = await fetch(\"/api/data\", {\n *     method: \"POST\",\n *     body: JSON.stringify({\n *       page: event.page,\n *       pageSize: event.rows,\n *       filters: event.filters,\n *       sorting: event.sorting,\n *       globalFilter: event.globalFilter,\n *     }),\n *   });\n *   const result = await response.json();\n *   setData(result.data);\n * };\n * ```\n */\nexport type LazyLoadEvent = {\n  first: number;\n  rows: number;\n  filters: ColumnFiltersState;\n  globalFilter: string;\n  sorting: SortingState[];\n  page: number;\n};\n\nexport type SortingState = {\n  id: string;\n  desc: boolean;\n};\n",
      "type": "registry:file"
    }
  ],
  "tailwind": {
    "config": {
      "theme": {
        "extend": {}
      }
    }
  }
}