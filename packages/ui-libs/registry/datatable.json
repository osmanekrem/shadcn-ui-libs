{
  "$schema": "https://ui.shadcn.com/schema.json",
  "name": "datatable",
  "type": "registry:component",
  "description": "A powerful, feature-rich React table component built on top of TanStack Table v8",
  "registryDependencies": [
    "table",
    "button",
    "checkbox",
    "input",
    "select",
    "dropdown-menu"
  ],
  "dependencies": [
    "@tanstack/react-table",
    "@tanstack/match-sorter-utils",
    "@dnd-kit/core",
    "@dnd-kit/modifiers",
    "@dnd-kit/sortable",
    "@dnd-kit/utilities",
    "lucide-react"
  ],
  "files": [
    {
      "path": "components/custom/datatable/index.tsx",
      "target": "components/custom/datatable/index.tsx",
      "content": "\"use client\";\n\nimport {\n  useEffect,\n  useMemo,\n  useState,\n  useCallback,\n  useRef,\n  lazy,\n  ComponentType,\n  Suspense,\n} from \"react\";\nimport {\n  useReactTable,\n  getCoreRowModel,\n  flexRender,\n  getFilteredRowModel,\n  getSortedRowModel,\n  getPaginationRowModel,\n  getFacetedRowModel,\n  getFacetedUniqueValues,\n  getFacetedMinMaxValues,\n  FilterFn,\n  SortingFn,\n  Header,\n  Table,\n} from \"@tanstack/react-table\";\nimport type {\n  Column,\n  ColumnDef,\n  TableOptions,\n  PaginationOptions,\n} from '@/types/types';\nimport type { TableTranslations } from '@/lib/i18n';\nimport { cn, getValue } from '@/lib/utils';\nimport { RankingInfo } from \"@tanstack/match-sorter-utils\";\nimport DebouncedInput from '@/ui-elements/debounced-input';\nimport {\n  Table as DefaultTable,\n  TableBody,\n  TableCell,\n  TableFooter,\n  TableHead,\n  TableHeader,\n  TableRow,\n} from '@/components/ui/table';\nimport { fuzzyFilter, fuzzySort, useExternalState } from '@/components/custom/datatable/actions';\n\n// Type definitions for lazy components\ntype FilterInputProps<T> = {\n  column: Column<T>;\n  translations?: TableTranslations;\n};\n\ntype ColumnVisibilityProps = {\n  table: Table<any>;\n  label?: string;\n};\n\ntype PaginationContentProps<T> = {\n  table: Table<T>;\n  pagination: PaginationOptions;\n  translations?: TableTranslations;\n  t: (key: string, params?: Record<string, any>) => string;\n};\n\n// Lazy load optional features for better code splitting\nconst FilterInputLazy = lazy(() =>\n  import(\"../filter-input.js\").then((module) => ({\n    default: module.default as unknown as ComponentType<FilterInputProps<any>>,\n  }))\n);\nconst ColumnVisibilityLazy = lazy(() =>\n  import(\"../column-visibility.js\").then((module) => ({\n    default: module.default as unknown as ComponentType<ColumnVisibilityProps>,\n  }))\n);\n\n// Pagination content component (lazy loaded)\nconst PaginationContentLazy = lazy(() =>\n  import(\"../pagination.js\").then((module) => ({\n    default: ({\n      table,\n      pagination,\n      translations,\n      t,\n    }: PaginationContentProps<any>) => {\n      const Pagination = module.default;\n      const GoToPage = module.GoToPage;\n      const PageSize = module.PageSize;\n\n      return (\n        <div className=\"flex items-center justify-between py-4\">\n          <div className=\"flex flex-wrap items-center justify-between gap-4 px-2 text-sm\">\n            {(\n              pagination.layout || [\"total\", \"pageSize\", \"goto\", \"buttons\"]\n            ).map((item: string) => {\n              switch (item) {\n                case \"total\":\n                  return (\n                    <span key=\"total\">\n                      {(\n                        pagination.totalLabel ||\n                        t(\"pagination.totalRecords\", {\n                          total: table.getFilteredRowModel().rows.length,\n                        })\n                      )?.replace(\n                        \"{total}\",\n                        String(table.getFilteredRowModel().rows.length)\n                      )}\n                    </span>\n                  );\n                case \"pageSize\":\n                  return (\n                    !!pagination.pageSizeOptions && (\n                      <PageSize\n                        key=\"pageSize\"\n                        pagination={pagination}\n                        onSetPageSize={(size: number) => {\n                          table.setPageSize(size);\n                        }}\n                        pageSize={table.getState().pagination.pageSize}\n                        label={pagination.pageSizeLabel}\n                        translations={translations}\n                      />\n                    )\n                  );\n                case \"goto\":\n                  return (\n                    <GoToPage\n                      key=\"goto\"\n                      label={pagination.goToPageLabel}\n                      currentPage={table.getState().pagination.pageIndex}\n                      onSetPage={(pageIndex: number) =>\n                        table.setPageIndex(pageIndex)\n                      }\n                      totalPages={table.getPageCount()}\n                      translations={translations}\n                    />\n                  );\n                case \"buttons\":\n                  const PaginationComponent =\n                    Pagination as React.ComponentType<any>;\n                  return (\n                    <PaginationComponent\n                      key=\"buttons\"\n                      canNextPage={table.getCanNextPage()}\n                      canPreviousPage={table.getCanPreviousPage()}\n                      currentPage={table.getState().pagination.pageIndex}\n                      onNext={() => table.nextPage()}\n                      onPrevious={() => table.previousPage()}\n                      onSetPage={(pageIndex: number) =>\n                        table.setPageIndex(pageIndex)\n                      }\n                      totalPages={table.getPageCount()}\n                      className={pagination.className}\n                      maxVisiblePages={pagination.maxVisiblePages}\n                      mode={pagination.mode}\n                      translations={translations}\n                    />\n                  );\n                default:\n                  return null;\n              }\n            })}\n          </div>\n        </div>\n      );\n    },\n  }))\n);\n\n// Conditional imports for @dnd-kit - only loaded when reorderable is true\nimport {\n  DraggableHeaderLazy,\n  DraggableTableCellLazy,\n} from '@/components/custom/datatable/draggable-header-lazy';\nimport {\n  DndWrapper,\n  SortableContextWrapper,\n  SensorsCreatorLazy,\n  lazyLoadDndUtilities,\n} from '@/components/custom/datatable/dnd-wrapper';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport React from \"react\";\n// Import only used security utilities for better tree-shaking\nimport { sanitizeSearchInput } from '@/lib/security/sanitize';\nimport {\n  validatePaginationParams,\n  validateSortingParams,\n} from '@/lib/security/validation';\nimport { RateLimiter } from '@/lib/security/rate-limiter';\nimport { defaultTranslations, createTranslator } from '@/lib/i18n';\nimport { Button } from '@/components/ui/button';\n\ntype DraggableFilterCellProps<TData> = {\n  readonly header: Header<TData, unknown>;\n  readonly colClassName?: string;\n  readonly TableHeadComponent: React.ElementType;\n  readonly translations?: TableTranslations;\n  readonly isTableDragging?: boolean;\n};\n\n// Inner component that always calls hooks for filter cells\nfunction DraggableFilterCellWithHooks<TData>({\n  header,\n  colClassName = \"\",\n  TableHeadComponent,\n  translations,\n  isTableDragging = false,\n  useSortableHook,\n  CSSUtil,\n}: DraggableFilterCellProps<TData> & {\n  useSortableHook: any;\n  CSSUtil: any;\n}) {\n  // Always call hooks - they're guaranteed to be available here\n  const { isDragging, setNodeRef, transform } = useSortableHook({\n    id: header.column.id,\n  });\n\n  const style: React.CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: CSSUtil.Translate.toString(transform),\n    transition:\n      isDragging || isTableDragging ? \"none\" : \"transform 0.05s ease-out\",\n    zIndex: isDragging ? 1 : 0,\n    width: header.getSize(),\n    minWidth: header.column.columnDef.minSize || 100,\n    maxWidth: header.column.columnDef.maxSize || \"none\",\n  };\n\n  return (\n    <TableHeadComponent\n      key={header.column.id}\n      colSpan={header.colSpan}\n      ref={setNodeRef}\n      style={style}\n      className={cn(\n        (header.column.columnDef as ColumnDef<TData>).headerClassName,\n        (header.column.columnDef as ColumnDef<TData>).className,\n        colClassName\n      )}\n    >\n      <div className=\"w-full\">\n        {flexRender(\n          !header.isPlaceholder && header.column.getCanFilter() ? (\n            <Suspense fallback={<div className=\"h-9 w-full\" />}>\n              <FilterInputLazy\n                column={header.column as unknown as Column<any>}\n                translations={translations}\n              />\n            </Suspense>\n          ) : null,\n          header.getContext()\n        )}\n      </div>\n    </TableHeadComponent>\n  );\n}\n\n// DraggableFilterCell component for filter row\nfunction DraggableFilterCell<TData>({\n  header,\n  colClassName = \"\",\n  TableHeadComponent,\n  translations,\n  isTableDragging = false,\n  reorderable = false,\n}: DraggableFilterCellProps<TData> & { reorderable?: boolean }) {\n  const [useSortableFn, setUseSortableFn] = React.useState<any>(null);\n  const [CSSFn, setCSSFn] = React.useState<any>(null);\n  const [isLoaded, setIsLoaded] = React.useState(false);\n\n  React.useEffect(() => {\n    if (reorderable && !isLoaded) {\n      Promise.all([\n        import(\"@dnd-kit/sortable\").then((mod) => mod.useSortable),\n        import(\"@dnd-kit/utilities\").then((mod) => mod.CSS),\n      ]).then(([useSortableFn, CSSUtil]) => {\n        setUseSortableFn(() => useSortableFn);\n        setCSSFn(() => CSSUtil);\n        setIsLoaded(true);\n      });\n    }\n  }, [reorderable, isLoaded]);\n\n  // If reorderable and loaded, use hook-using component\n  if (reorderable && isLoaded && useSortableFn && CSSFn) {\n    return (\n      <DraggableFilterCellWithHooks\n        header={header}\n        colClassName={colClassName}\n        TableHeadComponent={TableHeadComponent}\n        translations={translations}\n        isTableDragging={isTableDragging}\n        useSortableHook={useSortableFn}\n        CSSUtil={CSSFn}\n      />\n    );\n  }\n\n  // Non-draggable version (fallback or when reorderable is false)\n  return (\n    <TableHeadComponent\n      key={header.column.id}\n      colSpan={header.colSpan}\n      style={{\n        width: header.getSize(),\n        minWidth: header.column.columnDef.minSize || 100,\n        maxWidth: header.column.columnDef.maxSize || \"none\",\n      }}\n      className={cn(\n        (header.column.columnDef as ColumnDef<TData>).headerClassName,\n        (header.column.columnDef as ColumnDef<TData>).className,\n        colClassName\n      )}\n    >\n      <div className=\"w-full\">\n        {flexRender(\n          !header.isPlaceholder && header.column.getCanFilter() ? (\n            <Suspense fallback={<div className=\"h-9 w-full\" />}>\n              <FilterInputLazy\n                column={header.column as Column<TData>}\n                translations={translations}\n              />\n            </Suspense>\n          ) : null,\n          header.getContext()\n        )}\n      </div>\n    </TableHeadComponent>\n  );\n}\n\ndeclare module \"@tanstack/react-table\" {\n  //add fuzzy filter to the filterFns\n  interface FilterFns {\n    fuzzy: FilterFn<unknown>;\n  }\n  interface FilterMeta {\n    itemRank: RankingInfo;\n  }\n\n  interface SortingFns {\n    fuzzy: SortingFn<unknown>;\n  }\n}\n\n/**\n * Props for the DataTable component\n *\n * @template TData - The type of data in each row\n *\n * @example\n * ```tsx\n * <DataTable\n *   tableOptions={{\n *     data: users,\n *     columns: userColumns,\n *     pagination: { pageSize: 10, totalRecords: 100 },\n *   }}\n *   className=\"my-table\"\n * />\n * ```\n */\nexport type DataTableProps<TData> = {\n  /** Main configuration object for the table */\n  readonly tableOptions: TableOptions<TData>;\n  /** Additional CSS classes for the table container */\n  readonly className?: string;\n\n  /** Custom table component (default: shadcn Table) */\n  readonly TableComponent?: React.ElementType;\n  /** Custom table header component */\n  readonly TableHeaderComponent?: React.ElementType;\n  /** Custom table row component */\n  readonly TableRowComponent?: React.ElementType;\n  /** Custom table cell component */\n  readonly TableCellComponent?: React.ElementType;\n  /** Custom table head component */\n  readonly TableHeadComponent?: React.ElementType;\n  /** Custom table body component */\n  readonly TableBodyComponent?: React.ElementType;\n  /** Custom table footer component */\n  readonly TableFooterComponent?: React.ElementType;\n};\n\n/**\n * A powerful, feature-rich React table component built on top of TanStack Table v8 with shadcn/ui styling.\n *\n * Features:\n * - Advanced filtering (text, range, select, boolean, custom)\n * - Multi-column sorting with fuzzy search support\n * - Flexible pagination with customizable layouts\n * - Column reordering (drag & drop)\n * - Column resizing with interactive drag handles\n * - Row selection (single and multi-row)\n * - Global search with fuzzy matching\n * - Lazy loading for server-side data\n * - Column visibility controls\n * - Internationalization support (5 languages)\n * - Built-in security features (XSS protection, input sanitization)\n *\n * @template TData - The type of data in each row\n *\n * @param props - DataTable component props\n * @param props.tableOptions - Main configuration object for the table\n * @param props.className - Additional CSS classes for the table container\n * @param props.TableComponent - Custom table component (default: shadcn Table)\n * @param props.TableHeaderComponent - Custom table header component\n * @param props.TableRowComponent - Custom table row component\n * @param props.TableCellComponent - Custom table cell component\n * @param props.TableHeadComponent - Custom table head component\n * @param props.TableBodyComponent - Custom table body component\n * @param props.TableFooterComponent - Custom table footer component\n *\n * @returns The rendered DataTable component\n *\n * @example\n * ```tsx\n * import { DataTable, ColumnDef } from \"tanstack-shadcn-table\";\n *\n * type Person = {\n *   firstName: string;\n *   lastName: string;\n *   age: number;\n * };\n *\n * const columns: ColumnDef<Person>[] = [\n *   {\n *     accessorKey: \"firstName\",\n *     header: \"First Name\",\n *     filter: {\n *       type: \"text\",\n *       field: \"firstName\",\n *       placeholder: \"Search...\",\n *     },\n *   },\n *   {\n *     accessorKey: \"age\",\n *     header: \"Age\",\n *     filter: {\n *       type: \"range\",\n *       field: \"age\",\n *     },\n *   },\n * ];\n *\n * function App() {\n *   return (\n *     <DataTable\n *       tableOptions={{\n *         data: people,\n *         columns,\n *         pagination: {\n *           pageSize: 10,\n *           totalRecords: people.length,\n *         },\n *       }}\n *     />\n *   );\n * }\n * ```\n *\n * @example\n * ```tsx\n * // With lazy loading\n * <DataTable\n *   tableOptions={{\n *     data,\n *     columns,\n *     lazy: true,\n *     onLazyLoad: async (event) => {\n *       const result = await fetchData({\n *         page: event.page,\n *         pageSize: event.rows,\n *         filters: event.filters,\n *         sorting: event.sorting,\n *       });\n *       setData(result.data);\n *     },\n *     pagination: {\n *       pageSize: 20,\n *       totalRecords: 1000,\n *     },\n *   }}\n * />\n * ```\n */\nexport function DataTable<TData>({\n  tableOptions,\n  className = \"\",\n  TableComponent = DefaultTable,\n  TableHeaderComponent = TableHeader,\n  TableHeadComponent = TableHead,\n  TableRowComponent = TableRow,\n  TableCellComponent = TableCell,\n  TableBodyComponent = TableBody,\n  TableFooterComponent = TableFooter,\n}: DataTableProps<TData>) {\n  // Validation\n  if (!tableOptions.data || !Array.isArray(tableOptions.data)) {\n    console.warn(\"DataTable: data should be an array\");\n    return <div>No data provided</div>;\n  }\n\n  if (!tableOptions.columns || !Array.isArray(tableOptions.columns)) {\n    console.warn(\"DataTable: columns should be an array\");\n    return <div>No columns provided</div>;\n  }\n\n  // Security: Limit data size to prevent DoS\n  if (tableOptions.data.length > 100000) {\n    console.warn(\n      \"DataTable: Large dataset detected, consider using lazy loading\"\n    );\n  }\n\n  // Rate limiter for lazy loading\n  const rateLimiter = useMemo(() => new RateLimiter(10, 1000), []); // 10 requests per second\n\n  // Create translator function\n  const t = useMemo(() => {\n    const translations = tableOptions.translations || defaultTranslations;\n    return createTranslator(translations);\n  }, [tableOptions.translations]);\n\n  const columns = useMemo(() => {\n    return [\n      ...(tableOptions.rowSelection\n        ? [\n            {\n              id: \"selection\",\n              header: ({ table }) => (\n                <Checkbox\n                  checked={\n                    table.getIsAllPageRowsSelected() ||\n                    (table.getIsSomePageRowsSelected() && \"indeterminate\")\n                  }\n                  onCheckedChange={(value) =>\n                    table.toggleAllPageRowsSelected(!!value)\n                  }\n                  aria-label={t(\"selection.selectAll\")}\n                />\n              ),\n              className: \"!w-8 flex-none\",\n              cell: ({ row }) => (\n                <Checkbox\n                  checked={row.getIsSelected()}\n                  onCheckedChange={(value) => {\n                    row.toggleSelected(!!value);\n                  }}\n                  aria-label={t(\"selection.selectRow\")}\n                />\n              ),\n              enableSorting: false,\n              enableHiding: false,\n              enableResizing: false,\n              reorderable: false,\n              size: 40,\n              minSize: 40,\n              maxSize: 40,\n            } as ColumnDef<TData>,\n          ]\n        : []),\n      ...(tableOptions.columns || []),\n    ];\n  }, [tableOptions.columns, tableOptions.rowSelection, t]);\n  const data = useMemo(() => tableOptions.data, [tableOptions.data]);\n\n  const filterFn: FilterFn<any> = useCallback((row, columnId, filterValue) => {\n    if (!filterValue) return true;\n\n    const column = table.getColumn(columnId);\n    const columnDef = column?.columnDef as ColumnDef<TData>;\n\n    if (!columnDef) return true;\n\n    const filter = columnDef.filter;\n\n    if (!filter) return true;\n\n    const value = getValue(row.original, filter.field, null);\n\n    if (value === null) return true;\n\n    if (Array.isArray(filterValue)) {\n      // Check if it's a range filter (array of two numbers)\n      if (\n        filterValue.length === 2 &&\n        (typeof filterValue[0] === \"number\" ||\n          filterValue[0] === null ||\n          filterValue[0] === \"\") &&\n        (typeof filterValue[1] === \"number\" ||\n          filterValue[1] === null ||\n          filterValue[1] === \"\")\n      ) {\n        const [min, max] = filterValue;\n        const numValue = Number(value);\n        if (min !== null && min !== \"\" && numValue < min) return false;\n        if (max !== null && max !== \"\" && numValue > max) return false;\n        return true;\n      }\n      // Otherwise, treat as multi-select filter (array of strings)\n      if (filterValue.length === 0) return true;\n      const stringValue = String(value);\n      return filterValue.includes(stringValue);\n    }\n\n    if (typeof filterValue === \"string\") {\n      if (filterValue === \"\") return true;\n\n      if (filter?.type === \"boolean\") {\n        return String(value) === filterValue;\n      }\n\n      if (filter?.type === \"select\") {\n        return value === filterValue;\n      }\n\n      return String(value).toLowerCase().includes(filterValue.toLowerCase());\n    }\n\n    return true;\n  }, []);\n\n  const [columnFilters, onColumnFiltersChange] = useExternalState(\n    tableOptions.columnFilters,\n    tableOptions.onColumnFiltersChange,\n    []\n  );\n\n  const [sorting, onSortingChange] = useExternalState(\n    tableOptions.sorting,\n    tableOptions.onSortingChange,\n    []\n  );\n\n  const [pagination, onPaginationChange] = useExternalState(\n    tableOptions.paginationState,\n    tableOptions.onPaginationChange,\n    {\n      pageIndex: 0,\n      pageSize: tableOptions.pagination?.pageSize || 10,\n    }\n  );\n\n  const [columnVisibility, onColumnVisibilityChange] = useExternalState(\n    tableOptions.columnVisibility,\n    tableOptions.onColumnVisibilityChange,\n    {}\n  );\n\n  const [columnOrder, onColumnOrderChange] = useExternalState(\n    tableOptions.columnOrder,\n    tableOptions.onColumnOrderChange,\n    tableOptions.columns\n      .map((col) => col.id!)\n      .filter((id) => id !== \"selection\")\n  );\n\n  const [globalFilter, onGlobalFilterChange] = useExternalState(\n    tableOptions.globalFilter?.globalFilter,\n    tableOptions.globalFilter?.onGlobalFilterChange,\n    \"\"\n  );\n\n  const [rowSelection, onRowSelectionChange] = useExternalState(\n    tableOptions.rowSelection,\n    tableOptions.onRowSelectionChange,\n    {}\n  );\n\n  const [columnSizing, onColumnSizingChange] = useExternalState(\n    tableOptions.columnSizing,\n    tableOptions.onColumnSizingChange,\n    {}\n  );\n\n  const [showFilter, setShowFilter] = useExternalState(\n    tableOptions.showFilter,\n    tableOptions.onShowFilterChange,\n    false\n  );\n\n  // Track drag state to prevent animations during drag operations\n  const [isDragging, setIsDragging] = useState(false);\n\n  useEffect(() => {\n    if (tableOptions.lazy) {\n      const { onLazyLoad } = tableOptions;\n      if (onLazyLoad) {\n        // Rate limiting check\n        if (!rateLimiter.isAllowed(\"lazy-load\")) {\n          console.warn(\"Lazy load rate limit exceeded\");\n          return;\n        }\n\n        // Validate and sanitize parameters\n        const validatedPagination = validatePaginationParams(\n          pagination.pageIndex,\n          pagination.pageSize\n        );\n\n        const validatedSorting = validateSortingParams(sorting);\n\n        const sanitizedGlobalFilter =\n          typeof globalFilter === \"string\"\n            ? sanitizeSearchInput(globalFilter)\n            : \"\";\n\n        // Validate column filters\n        const validatedFilters = columnFilters.map((filter) => ({\n          ...filter,\n          value:\n            typeof filter.value === \"string\"\n              ? sanitizeSearchInput(filter.value)\n              : filter.value,\n        }));\n\n        onLazyLoad({\n          first: validatedPagination.pageIndex * validatedPagination.pageSize,\n          rows: validatedPagination.pageSize,\n          filters: validatedFilters,\n          globalFilter: sanitizedGlobalFilter,\n          page: validatedPagination.pageIndex,\n          sorting: validatedSorting,\n        });\n      }\n    }\n  }, [\n    columnFilters,\n    globalFilter,\n    pagination,\n    sorting,\n    tableOptions.lazy,\n    rateLimiter,\n  ]);\n\n  const table = useReactTable({\n    data,\n    columns,\n    state: {\n      columnFilters: tableOptions.columnFilters ?? columnFilters,\n      globalFilter,\n      sorting,\n      columnVisibility,\n      columnOrder: tableOptions.rowSelection\n        ? [\"selection\", ...columnOrder]\n        : columnOrder,\n      pagination,\n      rowSelection,\n      columnSizing,\n    },\n    rowCount: tableOptions.pagination?.totalRecords || data.length,\n    manualPagination: !!tableOptions.lazy,\n    filterFns: {\n      fuzzy: fuzzyFilter,\n    },\n    sortingFns: {\n      fuzzy: fuzzySort,\n    },\n    manualFiltering: tableOptions.lazy,\n    manualSorting: tableOptions.lazy,\n    globalFilterFn: \"fuzzy\",\n    enableRowSelection: (row) => {\n      if (tableOptions.enableRowSelectionFn) {\n        return tableOptions.enableRowSelectionFn(row);\n      }\n      return tableOptions.rowSelection !== undefined;\n    },\n    // Column sizing configuration\n    enableColumnResizing: tableOptions.enableColumnResizing ?? true,\n    columnResizeMode: tableOptions.columnResizeMode ?? \"onEnd\",\n    columnResizeDirection: tableOptions.columnResizeDirection ?? \"ltr\",\n    defaultColumn: {\n      filterFn: filterFn,\n      size: 150,\n      minSize: 20,\n      maxSize: Number.MAX_SAFE_INTEGER,\n      ...tableOptions.defaultColumn,\n    },\n    onGlobalFilterChange,\n    onColumnFiltersChange,\n    onSortingChange,\n    onPaginationChange,\n    onColumnVisibilityChange,\n    onColumnOrderChange,\n    onRowSelectionChange,\n    onColumnSizingChange,\n    getCoreRowModel: getCoreRowModel(),\n    getFilteredRowModel: getFilteredRowModel(),\n    getSortedRowModel: getSortedRowModel(),\n    getPaginationRowModel: getPaginationRowModel(),\n    getFacetedRowModel: getFacetedRowModel(),\n    getFacetedUniqueValues: getFacetedUniqueValues(),\n    getFacetedMinMaxValues: getFacetedMinMaxValues(),\n    initialState: {\n      columnVisibility: tableOptions.columnVisibility ?? {},\n      columnFilters: tableOptions.columnFilters ?? [],\n      sorting: tableOptions.sorting ?? [],\n      globalFilter: \"\",\n      columnSizing: tableOptions.columnSizing ?? {},\n    },\n  });\n\n  // Check if reorderable is enabled\n  const isReorderable = tableOptions.reorderable ?? false;\n\n  // Memoize sortable items to ensure consistency (only needed if reorderable)\n  const sortableItems = useMemo(() => {\n    if (!isReorderable) return [];\n    const tableColumnOrder = table.getState().columnOrder || [];\n    const nonSelectionColumns = tableColumnOrder.filter(\n      (id) => id !== \"selection\"\n    );\n    return nonSelectionColumns;\n  }, [table.getState().columnOrder, isReorderable]);\n\n  // Lazy load DND utilities only if reorderable\n  const [dndUtilities, setDndUtilities] = React.useState<{\n    closestCenter: any;\n    restrictToHorizontalAxis: any;\n    arrayMove: any;\n    horizontalListSortingStrategy: any;\n  } | null>(null);\n  const [isDndLoaded, setIsDndLoaded] = React.useState(!isReorderable);\n\n  React.useEffect(() => {\n    if (isReorderable && !isDndLoaded) {\n      lazyLoadDndUtilities().then((utils) => {\n        setDndUtilities(utils);\n        setIsDndLoaded(true);\n      });\n    }\n  }, [isReorderable, isDndLoaded]);\n\n  // Store sensors state - will be set by SensorsCreator component\n  const [sensors, setSensors] = React.useState<any[]>([]);\n\n  // Memoize the callback to avoid recreating it on every render\n  const handleSensorsReady = useCallback((newSensors: any[]) => {\n    setSensors(newSensors);\n  }, []);\n\n  const handleDragEnd = useCallback(\n    (event: any) => {\n      if (!dndUtilities) return;\n\n      const { active, over } = event;\n      setIsDragging(false);\n\n      if (active && over && active.id !== over.id) {\n        if (active.id === \"selection\") return;\n\n        const currentColumnOrder = table.getState().columnOrder || [];\n        const nonSelectionColumns = currentColumnOrder.filter(\n          (id) => id !== \"selection\"\n        );\n\n        const oldIndex = nonSelectionColumns.indexOf(active.id as string);\n        const newIndex = nonSelectionColumns.indexOf(over.id as string);\n\n        if (oldIndex === -1 || newIndex === -1) {\n          console.warn(\"Invalid indices\", { oldIndex, newIndex });\n          return;\n        }\n\n        const reorderedArray = dndUtilities.arrayMove(\n          nonSelectionColumns,\n          oldIndex,\n          newIndex\n        );\n\n        onColumnOrderChange(reorderedArray);\n      }\n    },\n    [onColumnOrderChange, table, dndUtilities]\n  );\n\n  const handleDragStart = useCallback(() => {\n    setIsDragging(true);\n  }, []);\n\n  // Add ref for table container\n  const tableContainerRef = useRef<HTMLDivElement>(null);\n\n  // Render table content (with or without DND wrapper)\n  const tableContent = (\n    <div className={`opal-datatable flex flex-col gap-2 ${className}`}>\n      <div className=\"flex flex-row gap-2 justify-between\">\n        <div className=\"flex flex-row gap-2\">\n          {tableOptions.globalFilter?.show && (\n            <DebouncedInput\n              value={globalFilter ?? \"\"}\n              onChange={(value) => {\n                const sanitizedValue =\n                  typeof value === \"string\"\n                    ? sanitizeSearchInput(value)\n                    : String(value);\n                table.setGlobalFilter(sanitizedValue);\n              }}\n              className=\"\"\n              placeholder={t(\"filters.searchAllColumns\")}\n              maxLength={500}\n              type=\"search\"\n            />\n          )}\n          {tableOptions.filter && tableOptions.showFilterButton && (\n            <Button onClick={() => setShowFilter(!showFilter)}>\n              {showFilter ? t(\"filters.hideFilter\") : t(\"filters.showFilter\")}\n            </Button>\n          )}\n        </div>\n        <div className=\"flex flex-row gap-2\">\n          {tableOptions.columnVisibility && (\n            <Suspense fallback={<div className=\"h-9 w-9\" />}>\n              <ColumnVisibilityLazy table={table} />\n            </Suspense>\n          )}\n        </div>\n      </div>\n      <div className=\"flex flex-col\" ref={tableContainerRef}>\n        {isReorderable && isDndLoaded && dndUtilities ? (\n          <SortableContextWrapper\n            items={sortableItems}\n            strategy={dndUtilities.horizontalListSortingStrategy}\n          >\n            <TableComponent>\n              <TableHeaderComponent>\n                {table.getHeaderGroups().map((headerGroup) => (\n                  <>\n                    <TableRowComponent\n                      key={\"header_\" + headerGroup.id}\n                      className={cn(tableOptions.rowClassName)}\n                    >\n                      {headerGroup.headers.map((header) => {\n                        return (\n                          <DraggableHeaderLazy\n                            header={header}\n                            colClassName={tableOptions.colClassName}\n                            TableHeadComponent={TableHeadComponent}\n                            key={header.column.id}\n                            reorderable={\n                              header.column.id === \"selection\"\n                                ? false\n                                : isReorderable\n                            }\n                            enableColumnResizing={\n                              tableOptions.enableColumnResizing\n                            }\n                          />\n                        );\n                      })}\n                    </TableRowComponent>\n                  </>\n                ))}\n\n                {showFilter && (\n                  <TableRowComponent\n                    className={cn(\n                      tableOptions.filterRowClassName,\n                      tableOptions.rowClassName\n                    )}\n                  >\n                    {table.getHeaderGroups().map((headerGroup) =>\n                      headerGroup.headers.map((header) => {\n                        // Render selection column filter\n                        if (header.column.id === \"selection\") {\n                          return (\n                            <TableHeadComponent\n                              key={header.column.id}\n                              colSpan={header.colSpan}\n                              style={{\n                                width: header.getSize(),\n                                minWidth:\n                                  header.column.columnDef.minSize || 100,\n                                maxWidth:\n                                  header.column.columnDef.maxSize || \"none\",\n                              }}\n                              className={cn(\n                                (header.column.columnDef as ColumnDef<TData>)\n                                  .headerClassName,\n                                (header.column.columnDef as ColumnDef<TData>)\n                                  .className,\n                                tableOptions.colClassName\n                              )}\n                            >\n                              <div className=\"w-full\">\n                                {flexRender(\n                                  header.isPlaceholder ? null : header.column.getCanFilter() ? (\n                                    <Suspense\n                                      fallback={<div className=\"h-9 w-full\" />}\n                                    >\n                                      <FilterInputLazy\n                                        column={header.column as Column<TData>}\n                                        translations={tableOptions.translations}\n                                      />\n                                    </Suspense>\n                                  ) : null,\n                                  header.getContext()\n                                )}\n                              </div>\n                            </TableHeadComponent>\n                          );\n                        }\n\n                        return (\n                          <DraggableFilterCell<TData>\n                            header={header}\n                            colClassName={tableOptions.colClassName}\n                            TableHeadComponent={TableHeadComponent}\n                            translations={tableOptions.translations}\n                            isTableDragging={isDragging}\n                            reorderable={isReorderable}\n                            key={header.column.id}\n                          />\n                        );\n                      })\n                    )}\n                  </TableRowComponent>\n                )}\n              </TableHeaderComponent>\n              <TableBodyComponent>\n                {table.getRowModel().rows.map((row) => {\n                  return (\n                    <TableRowComponent\n                      key={row.id}\n                      className={tableOptions.filterRowClassName}\n                    >\n                      {row.getVisibleCells().map((cell) => {\n                        return (\n                          <DraggableTableCellLazy<TData>\n                            cell={cell}\n                            colClassName={tableOptions.colClassName}\n                            TableCellComponent={TableCellComponent}\n                            reorderable={isReorderable}\n                            key={cell.column.id}\n                          />\n                        );\n                      })}\n                    </TableRowComponent>\n                  );\n                })}\n              </TableBodyComponent>\n              {table\n                .getAllLeafColumns()\n                .some(\n                  (col) =>\n                    (col.columnDef as ColumnDef<TData>)?.footer !== undefined\n                ) && (\n                <TableFooterComponent>\n                  {table.getFooterGroups().map((footerGroup) => {\n                    if (\n                      !footerGroup.headers.some(\n                        (header) =>\n                          (header.column.columnDef as ColumnDef<TData>)?.footer\n                      )\n                    ) {\n                      return null;\n                    }\n                    return (\n                      <TableRowComponent key={footerGroup.id}>\n                        {footerGroup.headers.map((header) => (\n                          <TableHeadComponent\n                            key={header.id}\n                            colSpan={header.colSpan}\n                            style={{ width: `${header.getSize()}px` }}\n                            className={cn(\n                              (header.column.columnDef as ColumnDef<TData>)\n                                ?.footerClassName,\n                              (header.column.columnDef as ColumnDef<TData>)\n                                .className,\n                              tableOptions.colClassName\n                            )}\n                          >\n                            {header.isPlaceholder\n                              ? null\n                              : flexRender(\n                                  header.column.columnDef.footer,\n                                  header.getContext()\n                                )}\n                          </TableHeadComponent>\n                        ))}\n                      </TableRowComponent>\n                    );\n                  })}\n                </TableFooterComponent>\n              )}\n            </TableComponent>\n          </SortableContextWrapper>\n        ) : (\n          <TableComponent>\n            <TableHeaderComponent>\n              {table.getHeaderGroups().map((headerGroup) => (\n                <>\n                  <TableRowComponent\n                    key={\"header_\" + headerGroup.id}\n                    className={cn(tableOptions.rowClassName)}\n                  >\n                    {headerGroup.headers.map((header) => {\n                      return (\n                        <DraggableHeaderLazy\n                          header={header}\n                          colClassName={tableOptions.colClassName}\n                          TableHeadComponent={TableHeadComponent}\n                          key={header.column.id}\n                          reorderable={false}\n                          enableColumnResizing={\n                            tableOptions.enableColumnResizing\n                          }\n                        />\n                      );\n                    })}\n                  </TableRowComponent>\n                </>\n              ))}\n\n              {showFilter && (\n                <TableRowComponent\n                  className={cn(\n                    tableOptions.filterRowClassName,\n                    tableOptions.rowClassName\n                  )}\n                >\n                  {table.getHeaderGroups().map((headerGroup) =>\n                    headerGroup.headers.map((header) => {\n                      if (header.column.id === \"selection\") {\n                        return (\n                          <TableHeadComponent\n                            key={header.column.id}\n                            colSpan={header.colSpan}\n                            style={{\n                              width: header.getSize(),\n                              minWidth: header.column.columnDef.minSize || 100,\n                              maxWidth:\n                                header.column.columnDef.maxSize || \"none\",\n                            }}\n                            className={cn(\n                              (header.column.columnDef as ColumnDef<TData>)\n                                .headerClassName,\n                              (header.column.columnDef as ColumnDef<TData>)\n                                .className,\n                              tableOptions.colClassName\n                            )}\n                          >\n                            <div className=\"w-full\">\n                              {flexRender(\n                                header.isPlaceholder ? null : header.column.getCanFilter() ? (\n                                  <Suspense\n                                    fallback={<div className=\"h-9 w-full\" />}\n                                  >\n                                    <FilterInputLazy\n                                      column={header.column as Column<TData>}\n                                      translations={tableOptions.translations}\n                                    />\n                                  </Suspense>\n                                ) : null,\n                                header.getContext()\n                              )}\n                            </div>\n                          </TableHeadComponent>\n                        );\n                      }\n\n                      return (\n                        <DraggableFilterCell<TData>\n                          header={header}\n                          colClassName={tableOptions.colClassName}\n                          TableHeadComponent={TableHeadComponent}\n                          translations={tableOptions.translations}\n                          isTableDragging={false}\n                          reorderable={false}\n                          key={header.column.id}\n                        />\n                      );\n                    })\n                  )}\n                </TableRowComponent>\n              )}\n            </TableHeaderComponent>\n            <TableBodyComponent>\n              {table.getRowModel().rows.map((row) => {\n                return (\n                  <TableRowComponent\n                    key={row.id}\n                    className={tableOptions.filterRowClassName}\n                  >\n                    {row.getVisibleCells().map((cell) => {\n                      return (\n                        <DraggableTableCellLazy<TData>\n                          cell={cell}\n                          colClassName={tableOptions.colClassName}\n                          TableCellComponent={TableCellComponent}\n                          reorderable={false}\n                          key={cell.column.id}\n                        />\n                      );\n                    })}\n                  </TableRowComponent>\n                );\n              })}\n            </TableBodyComponent>\n            {table\n              .getAllLeafColumns()\n              .some(\n                (col) =>\n                  (col.columnDef as ColumnDef<TData>)?.footer !== undefined\n              ) && (\n              <TableFooterComponent>\n                {table.getFooterGroups().map((footerGroup) => {\n                  if (\n                    !footerGroup.headers.some(\n                      (header) =>\n                        (header.column.columnDef as ColumnDef<TData>)?.footer\n                    )\n                  ) {\n                    return null;\n                  }\n                  return (\n                    <TableRowComponent key={footerGroup.id}>\n                      {footerGroup.headers.map((header) => (\n                        <TableHeadComponent\n                          key={header.id}\n                          colSpan={header.colSpan}\n                          style={{ width: `${header.getSize()}px` }}\n                          className={cn(\n                            (header.column.columnDef as ColumnDef<TData>)\n                              ?.footerClassName,\n                            (header.column.columnDef as ColumnDef<TData>)\n                              .className,\n                            tableOptions.colClassName\n                          )}\n                        >\n                          {header.isPlaceholder\n                            ? null\n                            : flexRender(\n                                header.column.columnDef.footer,\n                                header.getContext()\n                              )}\n                        </TableHeadComponent>\n                      ))}\n                    </TableRowComponent>\n                  );\n                })}\n              </TableFooterComponent>\n            )}\n          </TableComponent>\n        )}\n        {tableOptions.pagination && (\n          <Suspense\n            fallback={\n              <div className=\"flex items-center justify-between py-4\">\n                <div className=\"h-9 w-full\" />\n              </div>\n            }\n          >\n            <PaginationContentLazy\n              table={table}\n              pagination={tableOptions.pagination}\n              translations={tableOptions.translations}\n              t={t}\n            />\n          </Suspense>\n        )}\n      </div>\n    </div>\n  );\n\n  // Wrap with DndContext only if reorderable is enabled and loaded\n  if (isReorderable && isDndLoaded && dndUtilities) {\n    return (\n      <>\n        {/* Create sensors using hooks in component body */}\n        {isDndLoaded && (\n          <Suspense fallback={null}>\n            <SensorsCreatorLazy onSensorsReady={handleSensorsReady} />\n          </Suspense>\n        )}\n        {/* Render DND wrapper when sensors are ready */}\n        {sensors.length > 0 ? (\n          <DndWrapper\n            onDragEnd={handleDragEnd}\n            onDragStart={handleDragStart}\n            sensors={sensors}\n            collisionDetection={dndUtilities.closestCenter}\n            modifiers={[dndUtilities.restrictToHorizontalAxis]}\n          >\n            {tableContent}\n          </DndWrapper>\n        ) : (\n          tableContent\n        )}\n      </>\n    );\n  }\n\n  // Otherwise, render without DND wrapper\n  return tableContent;\n}\n\nexport default DataTable;\nexport { fuzzyFilter, fuzzySort };\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/datatable/actions.ts",
      "target": "components/custom/datatable/actions.ts",
      "content": "\"use client\";\n\nimport {\n  FilterFn,\n  isFunction,\n  SortingFn,\n  sortingFns,\n  Updater,\n} from \"@tanstack/react-table\";\nimport { rankItem, compareItems } from \"@tanstack/match-sorter-utils\";\nimport { OnChangeFn } from \"@tanstack/react-table\";\nimport { SetStateAction, useCallback, useRef, useState } from \"react\";\n\nexport const fuzzyFilter: FilterFn<any> = (row, columnId, value, addMeta) => {\n  // Rank the item\n  const itemRank = rankItem(row.getValue(columnId), value);\n\n  // Store the itemRank info\n  addMeta({\n    itemRank,\n  });\n\n  // Return if the item should be filtered in/out\n  return itemRank.passed;\n};\n\n// Define a custom fuzzy sort function that will sort by rank if the row has ranking information\nexport const fuzzySort: SortingFn<any> = (rowA, rowB, columnId) => {\n  let dir = 0;\n\n  // Only sort by rank if the column has ranking information\n  if (rowA.columnFiltersMeta[columnId]) {\n    dir = compareItems(\n      rowA.columnFiltersMeta[columnId]?.itemRank!,\n      rowB.columnFiltersMeta[columnId]?.itemRank!\n    );\n  }\n\n  // Provide an alphanumeric fallback for when the item ranks are equal\n  return dir === 0 ? sortingFns.alphanumeric(rowA, rowB, columnId) : dir;\n};\n\nexport function useExternalState<T>(\n  externalState: T | undefined,\n  onExternalChange: ((val: T) => void) | undefined,\n  initialInternalState?: T\n): [T, (val: React.SetStateAction<T>) => void] {\n  const [internalState, setInternalState] = useState<T>(\n    initialInternalState || (externalState as T)\n  );\n\n  const isControlled = externalState !== undefined;\n\n  const value = isControlled ? externalState : internalState;\n\n  const setValue = useCallback(\n    (updater: React.SetStateAction<T>) => {\n      const newValue =\n        typeof updater === \"function\"\n          ? (updater as (prev: T) => T)(value)\n          : updater;\n      if (isControlled) {\n        onExternalChange?.(newValue);\n      } else {\n        setInternalState(newValue);\n      }\n    },\n    [isControlled, value, onExternalChange]\n  );\n\n  return [value, setValue];\n}\n",
      "type": "registry:file"
    },
    {
      "path": "ui-elements/debounced-input.tsx",
      "target": "ui-elements/debounced-input.tsx",
      "content": "\"use client\";\n\nimport React, { InputHTMLAttributes, useEffect, useState, useRef } from \"react\";\nimport { Input } from \"../components/ui/input\";\n// Tree-shakeable import - only imports sanitizeSearchInput\nimport { sanitizeSearchInput } from \"../lib/security/sanitize\";\n\n// Simple rate limiter for input changes\nconst useRateLimit = (limit: number = 10, windowMs: number = 1000) => {\n  const requests = useRef<number[]>([]);\n\n  return () => {\n    const now = Date.now();\n    requests.current = requests.current.filter((time) => now - time < windowMs);\n\n    if (requests.current.length >= limit) {\n      return false;\n    }\n\n    requests.current.push(now);\n    return true;\n  };\n};\n\nfunction DebouncedInput({\n  value: initialValue,\n  onChange,\n  debounce = 500,\n  type = \"text\",\n  maxLength = 1000,\n  ...props\n}: {\n  value: string | number | undefined;\n  onChange: (value: string | number | undefined) => void;\n  debounce?: number;\n} & Omit<InputHTMLAttributes<HTMLInputElement>, \"onChange\">) {\n  const [value, setValue] = useState(initialValue);\n  const [isMounted, setIsMounted] = useState(false);\n  const checkRateLimit = useRateLimit();\n  const previousValueRef = useRef<string | number | undefined>(initialValue);\n\n  useEffect(() => {\n    if (type === \"number\") {\n      const numValue = Number(initialValue);\n      if (\n        isNaN(numValue) ||\n        initialValue === null ||\n        initialValue === undefined ||\n        initialValue === \"\"\n      ) {\n        previousValueRef.current = undefined;\n      } else {\n        previousValueRef.current = numValue;\n      }\n    }\n    setValue(initialValue);\n  }, [initialValue]);\n\n  useEffect(() => {\n    if (!isMounted) {\n      setIsMounted(true);\n      return;\n    }\n\n    // Rate limiting check\n    if (!checkRateLimit()) {\n      console.warn(\"Input rate limit exceeded\");\n      return;\n    }\n\n    const timeout = setTimeout(() => {\n      let sanitizedValue:\n        | string\n        | number\n        | undefined\n        | (string & readonly string[])\n        | (number & readonly string[]) = value;\n\n      // Sanitize based on input type\n      if (type === \"text\" || type === \"search\") {\n        sanitizedValue =\n          typeof value === \"string\"\n            ? sanitizeSearchInput(value)\n            : String(value);\n      } else if (type === \"number\") {\n        const numValue = Number(value);\n        if (\n          isNaN(numValue) ||\n          value === null ||\n          value === undefined ||\n          value === \"\"\n        ) {\n          sanitizedValue = undefined;\n        } else {\n          sanitizedValue = Math.max(-1000000, Math.min(1000000, numValue));\n        }\n      }\n\n      // Only call onChange if the value has actually changed\n      if (sanitizedValue !== previousValueRef.current) {\n        previousValueRef.current = sanitizedValue;\n        onChange(sanitizedValue);\n      }\n    }, debounce);\n\n    return () => clearTimeout(timeout);\n  }, [value, debounce, onChange, isMounted, type, checkRateLimit]);\n\n  const handleInputChange = (e: React.ChangeEvent<HTMLInputElement>) => {\n    const inputValue = e.target.value;\n\n    // Basic length validation\n    if (inputValue.length > maxLength) {\n      return;\n    }\n\n    // Additional validation for specific input types\n    if (type === \"number\") {\n      // Allow only valid number characters\n      if (!/^-?\\d*\\.?\\d*$/.test(inputValue) && inputValue !== \"\") {\n        return;\n      }\n    }\n\n    setValue(inputValue);\n  };\n\n  return (\n    <Input\n      {...props}\n      type={type}\n      maxLength={maxLength}\n      value={value}\n      onChange={handleInputChange}\n      // Security attributes\n      autoComplete={props.autoComplete || \"off\"}\n      spellCheck={false}\n    />\n  );\n}\n\nexport default DebouncedInput;\n\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/filter-input.tsx",
      "target": "components/custom/filter-input.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport DebouncedInput from '@/ui-elements/debounced-input';\nimport { Column, ColumnDef } from '@/types/types';\nimport {\n  Select,\n  SelectContent,\n  SelectItem,\n  SelectTrigger,\n  SelectValue,\n} from \"../ui/select\";\nimport { cn } from '@/lib/utils';\n// Tree-shakeable imports - only imports what's needed\nimport { sanitizeFilterValue, sanitizeSearchInput } from '@/lib/security/sanitize';\nimport {\n  TableTranslations,\n  defaultTranslations,\n  createTranslator,\n} from '@/lib/i18n';\n\nfunction FilterInput<T>({\n  column,\n  translations = defaultTranslations,\n}: {\n  column: Column<T>;\n  translations?: TableTranslations;\n}) {\n  const t = createTranslator(translations);\n  const columnFilterValue = column.getFilterValue();\n  const filter = (column.columnDef as ColumnDef<T>)?.filter;\n\n  const sortedUniqueValues = React.useMemo(\n    () =>\n      filter?.type === \"range\"\n        ? []\n        : Array.from(column.getFacetedUniqueValues().keys())\n            .sort()\n            .slice(0, 5000)\n            .map((value) =>\n              typeof value === \"string\" ? sanitizeSearchInput(value) : value\n            ),\n    [column.getFacetedUniqueValues(), filter?.type]\n  );\n\n  if (!filter?.field) return null;\n\n  // Sanitize current filter value\n  const sanitizedFilterValue = React.useMemo(() => {\n    if (!filter?.type) return columnFilterValue;\n    return sanitizeFilterValue(columnFilterValue, filter.type);\n  }, [columnFilterValue, filter?.type]);\n\n  if (filter?.type === \"range\") {\n    const {\n      minPlaceholder = t(\"filters.min\"),\n      maxPlaceholder = t(\"filters.max\"),\n      showLimit = false,\n      minLimit,\n      maxLimit,\n    } = filter ?? {};\n\n    // Validate and sanitize range limits\n    const safeMinLimit =\n      typeof minLimit === \"number\"\n        ? Math.max(-1000000, Math.min(1000000, minLimit))\n        : minLimit;\n    const safeMaxLimit =\n      typeof maxLimit === \"number\"\n        ? Math.max(-1000000, Math.min(1000000, maxLimit))\n        : maxLimit;\n\n    return (\n      <div className=\"flex space-x-1 w-full\">\n        <DebouncedInput\n          type=\"number\"\n          min={\n            safeMinLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[0] ?? \"\")\n              : safeMinLimit\n          }\n          max={\n            safeMaxLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[1] ?? \"\")\n              : safeMaxLimit\n          }\n          value={(sanitizedFilterValue as [number, number])?.[0] ?? \"\"}\n          onChange={(value) => {\n            // Validate and sanitize numeric input\n            const numValue =\n              value === \"\" || value === null || value === undefined\n                ? undefined\n                : Number(value);\n\n            if (\n              numValue !== undefined &&\n              (isNaN(numValue) || numValue < -1000000 || numValue > 1000000)\n            ) {\n              return; // Reject invalid values\n            }\n            column.setFilterValue((old: [number, number]) => {\n              if (numValue === undefined && old?.[1] === undefined) {\n                return undefined;\n              }\n              return [numValue, old?.[1]];\n            });\n          }}\n          placeholder={`${sanitizeSearchInput(minPlaceholder)} ${\n            showLimit\n              ? safeMinLimit === \"faceted\"\n                ? column.getFacetedMinMaxValues()?.[0] !== undefined\n                  ? `(${column.getFacetedMinMaxValues()?.[0]})`\n                  : \"\"\n                : `(${safeMinLimit})`\n              : \"\"\n          }`}\n          className=\"flex-1 min-w-16 h-8\"\n        />\n        <DebouncedInput\n          type=\"number\"\n          min={\n            safeMinLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[0] ?? \"\")\n              : safeMinLimit\n          }\n          max={\n            safeMaxLimit === \"faceted\"\n              ? Number(column.getFacetedMinMaxValues()?.[1] ?? \"\")\n              : safeMaxLimit\n          }\n          value={(sanitizedFilterValue as [number, number])?.[1] ?? \"\"}\n          onChange={(value) => {\n            // Validate and sanitize numeric input\n            const numValue =\n              value === \"\" || value === null || value === undefined\n                ? undefined\n                : Number(value);\n            if (\n              numValue !== undefined &&\n              (isNaN(numValue) || numValue < -1000000 || numValue > 1000000)\n            ) {\n              return; // Reject invalid values\n            }\n            column.setFilterValue((old: [number, number]) => {\n              if (numValue === undefined && old?.[0] === undefined) {\n                return undefined;\n              }\n              return [old?.[0], numValue];\n            });\n          }}\n          placeholder={`${sanitizeSearchInput(maxPlaceholder)} ${\n            showLimit\n              ? safeMaxLimit === \"faceted\"\n                ? column.getFacetedMinMaxValues()?.[1] !== undefined\n                  ? `(${column.getFacetedMinMaxValues()?.[1]})`\n                  : \"\"\n                : `(${safeMaxLimit})`\n              : \"\"\n          }`}\n          className=\"flex-1 min-w-16 h-8\"\n        />\n      </div>\n    );\n  }\n\n  if (filter?.type === \"select\") {\n    const {\n      options,\n      optionLabel = \"label\",\n      optionValue = \"value\",\n      allLabel = t(\"filters.all\"),\n    } = filter ?? {};\n\n    // Sanitize options\n    const safeOptions = (options ?? sortedUniqueValues).slice(0, 1000); // Limit options to prevent DoS\n\n    return (\n      <Select\n        value={(sanitizedFilterValue as string) ?? \"all\"}\n        onValueChange={(value) => {\n          const sanitizedValue = sanitizeSearchInput(value);\n          column.setFilterValue(sanitizedValue === \"all\" ? \"\" : sanitizedValue);\n        }}\n      >\n        <SelectTrigger className=\"h-8 w-full\">\n          <SelectValue placeholder={sanitizeSearchInput(allLabel)} />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"all\">{sanitizeSearchInput(allLabel)}</SelectItem>\n          {safeOptions.map((option: any, index: number) => {\n            const value =\n              typeof option === \"object\"\n                ? sanitizeSearchInput(String(option[optionValue]))\n                : sanitizeSearchInput(String(option));\n            const label =\n              typeof option === \"object\"\n                ? sanitizeSearchInput(String(option[optionLabel]))\n                : sanitizeSearchInput(String(option));\n            return (\n              <SelectItem value={value} key={`${value}-${index}`}>\n                {label}\n              </SelectItem>\n            );\n          })}\n        </SelectContent>\n      </Select>\n    );\n  }\n\n  if (filter?.type === \"boolean\") {\n    const {\n      trueLabel = t(\"filters.true\"),\n      falseLabel = t(\"filters.false\"),\n      allLabel = t(\"filters.all\"),\n    } = filter ?? {};\n    return (\n      <Select\n        value={(sanitizedFilterValue as string) ?? \"all\"}\n        onValueChange={(value) => {\n          // Only allow specific boolean values\n          if (![\"all\", \"true\", \"false\"].includes(value)) return;\n          column.setFilterValue(value === \"all\" ? \"\" : value);\n        }}\n      >\n        <SelectTrigger className=\"h-8 w-full\">\n          <SelectValue placeholder={sanitizeSearchInput(allLabel)} />\n        </SelectTrigger>\n        <SelectContent>\n          <SelectItem value=\"all\">{sanitizeSearchInput(allLabel)}</SelectItem>\n          <SelectItem value=\"true\">{sanitizeSearchInput(trueLabel)}</SelectItem>\n          <SelectItem value=\"false\">\n            {sanitizeSearchInput(falseLabel)}\n          </SelectItem>\n        </SelectContent>\n      </Select>\n    );\n  }\n\n  if (filter?.type === \"text\") {\n    return (\n      <>\n        {filter?.showList && (\n          <datalist id={column.id + \"list\"}>\n            {sortedUniqueValues\n              .slice(0, 100)\n              .map((value: any, index: number) => (\n                <option value={value} key={`${value}-${index}`} />\n              ))}\n          </datalist>\n        )}\n        <DebouncedInput\n          className={cn(\"w-full h-8\", filter?.className)}\n          onChange={(value) => {\n            const sanitizedValue = sanitizeSearchInput(String(value));\n            column.setFilterValue(sanitizedValue);\n          }}\n          placeholder={`${sanitizeSearchInput(filter?.field)} ${filter?.showTotal ? `(${Math.min(column.getFacetedUniqueValues().size, 9999)})` : \"\"}`}\n          type=\"text\"\n          value={(sanitizedFilterValue ?? \"\") as string}\n          list={filter?.showList ? column.id + \"list\" : undefined}\n          maxLength={1000} // Prevent extremely long inputs\n        />\n      </>\n    );\n  }\n\n  if (filter?.type === \"custom\") {\n    const { component: CustomComponent, ...rest } = filter;\n    // Note: Custom components should implement their own security measures\n    return <CustomComponent column={column} {...rest} />;\n  }\n\n  return null;\n}\n\nexport default FilterInput;\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/column-visibility.tsx",
      "target": "components/custom/column-visibility.tsx",
      "content": "\"use client\";\n\nimport { flexRender, isFunction, Table } from \"@tanstack/react-table\";\nimport {\n  DropdownMenu,\n  DropdownMenuContent,\n  DropdownMenuTrigger,\n  DropdownMenuCheckboxItem,\n} from \"../ui/dropdown-menu\";\nimport { Button } from \"../ui/button\";\n\nexport default function ColumnVisibility({\n  table,\n  label,\n}: {\n  table: Table<any>;\n  label?: string;\n}) {\n  return (\n    <DropdownMenu>\n      <DropdownMenuTrigger asChild>\n        <Button variant=\"outline\" className=\"ml-auto\">\n          {label || \"Columns\"}\n        </Button>\n      </DropdownMenuTrigger>\n      <DropdownMenuContent align=\"end\">\n        {table\n          .getAllColumns()\n          .filter((column) => column.getCanHide())\n          .map((column) => {\n            return (\n              <DropdownMenuCheckboxItem\n                key={column.id}\n                className=\"capitalize\"\n                checked={column.getIsVisible()}\n                onCheckedChange={(value) => column.toggleVisibility(!!value)}\n              >\n                {isFunction(column.columnDef.header)\n                  ? flexRender(\n                      column.columnDef.header,\n                      table\n                        .getHeaderGroups()\n                        .find((headerGroup) =>\n                          headerGroup.headers.some(\n                            (header) => header.id === column.id\n                          )\n                        )\n                        ?.headers.find((header) => header.id === column.id)!\n                        .getContext()!\n                    )\n                  : column.columnDef.header || column.id}\n              </DropdownMenuCheckboxItem>\n            );\n          })}\n      </DropdownMenuContent>\n    </DropdownMenu>\n  );\n}\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/pagination.tsx",
      "target": "components/custom/pagination.tsx",
      "content": "\"use client\";\n\nimport React, { useCallback } from \"react\";\nimport { Button } from \"../ui/button\";\nimport { cn } from '@/lib/utils';\nimport {\n  ChevronLeftIcon,\n  ChevronRightIcon,\n  ChevronsLeftIcon,\n  ChevronsRightIcon,\n  Ellipsis,\n} from \"lucide-react\";\nimport { PaginationOptions } from '@/types/types';\nimport DebouncedInput from '@/ui-elements/debounced-input';\nimport { Select, SelectContent, SelectItem, SelectTrigger } from \"../ui/select\";\nimport {\n  TableTranslations,\n  defaultTranslations,\n  createTranslator,\n} from '@/lib/i18n';\n\ntype Props = {\n  totalPages: number;\n  currentPage: number;\n  canPreviousPage: boolean;\n  canNextPage: boolean;\n  onPrevious: () => void;\n  onNext: () => void;\n  onSetPage: (page: number) => void;\n  className?: string;\n  mode?: \"default\" | \"compact\" | \"advanced\";\n  maxVisiblePages?: number;\n  translations?: TableTranslations;\n};\n\nexport default function Pagination({\n  onNext,\n  onPrevious,\n  onSetPage,\n  canNextPage,\n  canPreviousPage,\n  totalPages = 0,\n  currentPage = 0,\n  className,\n  mode = \"default\",\n  maxVisiblePages = 7,\n  translations = defaultTranslations,\n}: Props) {\n  const t = createTranslator(translations);\n\n  const getVisiblePages = useCallback(() => {\n    const pages = [];\n\n    switch (mode) {\n      case \"advanced\": {\n        if (totalPages <= maxVisiblePages) {\n          // Case 1: 7 veya daha az sayfa - hepsini gster (1,2,3,4,5,6,7)\n          for (let i = 0; i < totalPages; i++) {\n            pages.push(i);\n          }\n        } else {\n          // 7'den fazla sayfa iin case hesaplama\n          const leftPages = Math.floor((maxVisiblePages - 3) / 2); // Sol tarafta ka sayfa (ellipsis ve first/last hari)\n          const rightPages = maxVisiblePages - 3 - leftPages; // Sa tarafta ka sayfa\n\n          const isNearStart = currentPage < leftPages + 1;\n          const isNearEnd = currentPage >= totalPages - rightPages - 1;\n\n          if (isNearStart) {\n            // Case 2: Balangta (1,2,3,4,5,...,12)\n            for (let i = 0; i < maxVisiblePages - 2; i++) {\n              // maxVisiblePages-2 = 5 sayfa\n              pages.push(i);\n            }\n            pages.push(-1); // ellipsis\n            pages.push(totalPages - 1); // last page\n          } else if (isNearEnd) {\n            // Case 4: Sonda (1,...,8,9,10,11,12)\n            pages.push(0); // first page\n            pages.push(-1); // ellipsis\n            for (\n              let i = totalPages - (maxVisiblePages - 2);\n              i < totalPages;\n              i++\n            ) {\n              // Son 5 sayfa\n              pages.push(i);\n            }\n          } else {\n            // Case 3: Ortada (1,...,5,6,7,...,12)\n            pages.push(0); // first page\n            pages.push(-1); // left ellipsis\n\n            // Ortada 3 sayfa: current-1, current, current+1\n            const middlePages = maxVisiblePages - 4; // 4 = first + 2 ellipsis + last\n            const startMiddle = currentPage - Math.floor(middlePages / 2);\n\n            for (let i = 0; i < middlePages; i++) {\n              pages.push(startMiddle + i);\n            }\n\n            pages.push(-2); // right ellipsis\n            pages.push(totalPages - 1); // last page\n          }\n        }\n        break;\n      }\n\n      case \"default\": {\n        if (totalPages <= maxVisiblePages) {\n          for (let i = 0; i < totalPages; i++) {\n            pages.push(i);\n          }\n        } else {\n          // 5'ten fazla sayfa: kaydrmal window + ellipsis\n          const isNearEnd = currentPage >= totalPages - maxVisiblePages + 1;\n\n          if (isNearEnd) {\n            // Son ksmda: son 5 sayfay gster (8,9,10,11,12)\n            for (let i = totalPages - maxVisiblePages; i < totalPages; i++) {\n              pages.push(i);\n            }\n          } else {\n            // Bata veya ortada: current'tan balayp 4 sayfa + ellipsis + last\n            const startPage = Math.max(0, currentPage);\n            for (let i = startPage; i < startPage + maxVisiblePages - 1; i++) {\n              pages.push(i);\n            }\n            pages.push(-1); // ellipsis\n            pages.push(totalPages - 1); // last page\n          }\n        }\n        break;\n      }\n\n      case \"compact\": {\n        if (totalPages <= maxVisiblePages) {\n          for (let i = 0; i < totalPages; i++) {\n            pages.push(i);\n          }\n        } else {\n          let start = Math.max(\n            0,\n            currentPage - Math.floor(maxVisiblePages / 2)\n          );\n          let end = Math.min(totalPages - 1, start + maxVisiblePages - 1);\n\n          if (end === totalPages - 1) {\n            start = Math.max(0, end - maxVisiblePages + 1);\n          }\n\n          for (let i = start; i <= end; i++) {\n            pages.push(i);\n          }\n        }\n        break;\n      }\n    }\n\n    return pages;\n  }, [totalPages, currentPage, mode, maxVisiblePages]);\n\n  return (\n    <div className={cn(\"flex items-center gap-1\", className)}>\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onSetPage(0)}\n        disabled={!canPreviousPage}\n        aria-label={t(\"pagination.first\")}\n      >\n        <ChevronsLeftIcon className=\"h-4 w-4\" />\n      </Button>\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onPrevious()}\n        disabled={!canPreviousPage}\n        aria-label={t(\"pagination.previous\")}\n      >\n        <ChevronLeftIcon className=\"h-4 w-4\" />\n      </Button>\n\n      {/* Page Numbers */}\n      {getVisiblePages().map((page, index) => {\n        if (page === -1 || page === -2) {\n          return (\n            <span\n              key={index}\n              className=\"size-9 flex items-center justify-center text-gray-500\"\n            >\n              <Ellipsis className=\"h-4 w-4\" />\n            </span>\n          );\n        }\n\n        return (\n          <Button\n            key={index}\n            variant={currentPage === page ? \"default\" : \"ghost\"}\n            size=\"icon\"\n            onClick={() => onSetPage(page)}\n          >\n            {page + 1}\n          </Button>\n        );\n      })}\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onNext()}\n        disabled={!canNextPage}\n        aria-label={t(\"pagination.next\")}\n      >\n        <ChevronRightIcon className=\"h-4 w-4\" />\n      </Button>\n      <Button\n        variant=\"ghost\"\n        size={\"icon\"}\n        onClick={() => onSetPage(totalPages - 1)}\n        disabled={!canNextPage || totalPages === 0}\n        aria-label={t(\"pagination.last\")}\n      >\n        <ChevronsRightIcon className=\"h-4 w-4\" />\n      </Button>\n    </div>\n  );\n}\n\ntype GoToPageProps = {\n  totalPages: number;\n  currentPage: number;\n  onSetPage: (page: number) => void;\n  className?: string;\n  label?: string;\n  translations?: TableTranslations;\n};\n\nexport function GoToPage({\n  currentPage,\n  onSetPage,\n  totalPages,\n  className,\n  label,\n  translations = defaultTranslations,\n}: GoToPageProps) {\n  const t = createTranslator(translations);\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      {label && (\n        <span className=\"text-sm text-gray-700\">\n          {label || t(\"pagination.goToPage\")}\n        </span>\n      )}\n      <DebouncedInput\n        type=\"number\"\n        min={1}\n        max={totalPages}\n        value={currentPage + 1}\n        onChange={(value) => {\n          const page = value ? Number(value) - 1 : 0;\n          onSetPage(page);\n        }}\n        className=\"w-16 h-8 border border-gray-300 rounded-md px-2\"\n        placeholder={t(\"pagination.page\")}\n      />\n      <span className=\"text-sm text-gray-700\">\n        {t(\"pagination.of\")} {totalPages}\n      </span>\n    </div>\n  );\n}\n\nexport function PageSize({\n  pageSize,\n  className,\n  onSetPageSize,\n  pagination,\n  label,\n  translations = defaultTranslations,\n}: {\n  onSetPageSize: (size: number) => void;\n  pageSize: number;\n  className?: string;\n  pagination: PaginationOptions;\n  label?: string;\n  translations?: TableTranslations;\n}) {\n  const t = createTranslator(translations);\n\n  return (\n    <div className={cn(\"flex items-center gap-2\", className)}>\n      {label && (\n        <span className=\"text-sm truncate text-gray-700\">\n          {label || t(\"pagination.rowsPerPage\")}\n        </span>\n      )}\n      <Select\n        value={pageSize.toString()}\n        onValueChange={(e: string) => {\n          const size = parseInt(e, 10);\n          if (!isNaN(size) && size > 0) {\n            onSetPageSize(size);\n          }\n        }}\n      >\n        <SelectTrigger>\n          <span className=\"text-sm text-gray-700\">{pageSize}</span>\n        </SelectTrigger>\n        <SelectContent>\n          {pagination.pageSizeOptions?.map((size) => (\n            <SelectItem key={size} value={size.toString()}>\n              {size}\n            </SelectItem>\n          ))}\n        </SelectContent>\n      </Select>\n    </div>\n  );\n}\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/draggable-header.tsx",
      "target": "components/custom/draggable-header.tsx",
      "content": "\"use client\";\n\nimport { flexRender, Header } from \"@tanstack/react-table\";\nimport React, { CSSProperties } from \"react\";\n\nimport { useSortable } from \"@dnd-kit/sortable\";\nimport { CSS } from \"@dnd-kit/utilities\";\nimport { TableCell, TableHead } from \"../ui/table\";\nimport { ColumnDef } from '@/types/types';\nimport { ArrowDownUp, MenuIcon, SortAsc, SortDesc } from \"lucide-react\";\nimport { cn } from '@/lib/utils';\nimport { Button } from \"../ui/button\";\nimport { Cell } from \"@tanstack/react-table\";\nimport ColumnResizeHandle from \"./column-resize-handle\";\n\ntype DraggableHeaderProps<T> = {\n  header: Header<T, unknown>;\n  colClassName?: string;\n  TableHeadComponent?: React.ElementType;\n  reorderable?: boolean;\n  enableColumnResizing?: boolean;\n};\n\nexport function DraggableHeader<T>({\n  header,\n  TableHeadComponent = TableHead,\n  colClassName = \"\",\n  reorderable = false,\n  enableColumnResizing = false,\n}: DraggableHeaderProps<T>) {\n  const isSelectionColumn = header.column.id === \"selection\";\n\n  const { attributes, isDragging, listeners, setNodeRef, transform } =\n    useSortable({\n      id: header.column.id,\n      disabled: isSelectionColumn || !reorderable,\n    });\n\n  const style: CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: isSelectionColumn\n      ? undefined\n      : CSS.Translate.toString(transform),\n    transition: isSelectionColumn\n      ? undefined\n      : isDragging\n        ? \"none\"\n        : \"transform 0.05s ease-out\",\n    zIndex: isDragging ? 1 : 0,\n    width: header.getSize(),\n    minWidth: header.column.columnDef.minSize || 100,\n    maxWidth: header.column.columnDef.maxSize || \"none\",\n  };\n\n  return (\n    <TableHeadComponent\n      colSpan={header.colSpan}\n      ref={setNodeRef}\n      style={style}\n      onClick={() => {\n        if (\n          header.column.getCanSort() &&\n          (header.column.columnDef as ColumnDef<T>).enableSorting\n        ) {\n          header.column.toggleSorting();\n        }\n      }}\n      className={cn(\n        (header.column.columnDef as ColumnDef<T>).headerClassName,\n        (header.column.columnDef as ColumnDef<T>).className,\n        colClassName,\n        !!(header.column.columnDef as ColumnDef<T>).enableSorting &&\n          \"cursor-pointer select-none\",\n        \"relative\",\n        enableColumnResizing && \"group\"\n      )}\n    >\n      {header.isPlaceholder ? null : (\n        <>\n          <div className=\"flex items-center justify-between gap-2 w-full\">\n            <div className=\"flex items-center gap-1 flex-1 min-w-0\">\n              <span className=\"truncate\">\n                {flexRender(\n                  header.column.columnDef.header,\n                  header.getContext()\n                )}\n              </span>\n              {(!!(header.column.columnDef as ColumnDef<T>).enableSorting &&\n                {\n                  asc: <SortAsc className=\"inline size-4 flex-shrink-0\" />,\n                  desc: <SortDesc className=\"inline size-4 flex-shrink-0\" />,\n                }[header.column.getIsSorted() as string]) ?? (\n                <ArrowDownUp className=\"inline size-4 flex-shrink-0\" />\n              )}\n            </div>\n            {reorderable &&\n              header.column.id !== \"selection\" &&\n              ((header.column.columnDef as ColumnDef<T>).reorderable ??\n                true) && (\n                <Button\n                  variant=\"ghost\"\n                  className=\"size-6 p-0 flex-shrink-0\"\n                  {...attributes}\n                  {...listeners}\n                >\n                  <span className=\"sr-only\">Drag to reorder</span>\n                  <MenuIcon className=\"size-4\" />\n                </Button>\n              )}\n          </div>\n          {enableColumnResizing && <ColumnResizeHandle header={header} />}\n        </>\n      )}\n    </TableHeadComponent>\n  );\n}\n\nexport function DraggableTableCell<T>({\n  cell,\n  colClassName = \"\",\n  TableCellComponent = TableCell,\n}: {\n  cell: Cell<T, unknown>;\n  colClassName?: string;\n  TableCellComponent?: React.ElementType;\n}) {\n  const isSelectionColumn = cell.column.id === \"selection\";\n\n  const { isDragging, setNodeRef, transform } = useSortable({\n    id: cell.column.id,\n    disabled: isSelectionColumn,\n  });\n\n  const style: CSSProperties = {\n    opacity: isDragging ? 0.8 : 1,\n    position: \"relative\",\n    transform: isSelectionColumn\n      ? undefined\n      : CSS.Translate.toString(transform),\n    transition: isSelectionColumn\n      ? undefined\n      : isDragging\n        ? \"none\"\n        : \"transform 0.05s ease-out\",\n    zIndex: isDragging ? 1 : 0,\n    width: cell.column.getSize(),\n    minWidth: cell.column.columnDef.minSize || 100,\n    maxWidth: cell.column.columnDef.maxSize || \"none\",\n  };\n\n  return (\n    <TableCellComponent\n      style={style}\n      ref={setNodeRef}\n      className={cn(\n        (cell.column.columnDef as ColumnDef<T>).className,\n        colClassName\n      )}\n    >\n      <div className=\"truncate\">\n        {flexRender(cell.column.columnDef.cell, cell.getContext())}\n      </div>\n    </TableCellComponent>\n  );\n}\n",
      "type": "registry:file"
    },
    {
      "path": "components/custom/column-resize-handle/index.tsx",
      "target": "components/custom/column-resize-handle/index.tsx",
      "content": "\"use client\";\n\nimport React from \"react\";\nimport { Header } from \"@tanstack/react-table\";\nimport { cn } from '@/lib/utils';\n\ninterface ColumnResizeHandleProps<TData> {\n  header: Header<TData, unknown>;\n  className?: string;\n}\n\nexport function ColumnResizeHandle<TData>({\n  header,\n  className,\n}: ColumnResizeHandleProps<TData>) {\n  const { column } = header;\n  const isResizing = column.getIsResizing();\n\n  if (!column.getCanResize()) {\n    return null;\n  }\n\n  return (\n    <div\n      className={cn(\n        \"absolute right-0 top-0 h-full w-1 cursor-col-resize select-none touch-none bg-transparent hover:bg-blue-500 active:bg-blue-600 focus:bg-blue-500 focus:outline-none\",\n        isResizing && \"bg-blue-500\",\n        className\n      )}\n      onMouseDown={header.getResizeHandler()}\n      onTouchStart={header.getResizeHandler()}\n      role=\"separator\"\n      aria-label={`Resize ${header.column.id} column`}\n      aria-orientation=\"vertical\"\n      tabIndex={0}\n      onKeyDown={(e) => {\n        if (e.key === \"Enter\" || e.key === \" \") {\n          e.preventDefault();\n          // Could implement keyboard-based resizing here\n        }\n      }}\n      style={{\n        transform: \"translateX(50%)\",\n      }}\n    >\n      <div className=\"h-full w-full\" />\n    </div>\n  );\n}\n\nexport default ColumnResizeHandle;\n",
      "type": "registry:file"
    },
    {
      "path": "lib/utils.ts",
      "target": "lib/utils.ts",
      "content": "import { GetFieldType } from \"./utils.types\";\nimport { type ClassValue, clsx } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\n/**\n * Internal utility function to merge Tailwind CSS classes with clsx and tailwind-merge.\n * This ensures proper class merging and conflict resolution for Tailwind utilities.\n *\n * **Note:** This function is for internal use only and is not exported from the main package.\n * If you need a similar utility, use `clsx` and `tailwind-merge` directly.\n *\n * @param inputs - Variable number of class values (strings, objects, arrays, etc.)\n * @returns Merged class string with Tailwind conflicts resolved\n *\n * @internal\n */\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n\n/**\n * Safely retrieves a nested value from an object using a dot-notation path string.\n * Supports nested objects, arrays, and optional default values.\n *\n * @template TData - The type of the data object\n * @template TPath - The path string type (e.g., \"user.name\" or \"items[0].id\")\n * @template TDefault - The type of the default value (optional)\n *\n * @param data - The data object to extract the value from\n * @param path - Dot-notation path string (e.g., \"user.profile.name\" or \"items[0].id\")\n * @param defaultValue - Optional default value to return if the path doesn't exist\n * @returns The value at the specified path, or the default value if not found\n *\n * @example\n * ```tsx\n * import { getValue } from \"tanstack-shadcn-table\";\n *\n * const user = {\n *   name: \"John\",\n *   profile: {\n *     email: \"john@example.com\",\n *   },\n *   items: [{ id: 1 }, { id: 2 }],\n * };\n *\n * // Get nested value\n * const email = getValue(user, \"profile.email\"); // \"john@example.com\"\n *\n * // Get array value\n * const firstItemId = getValue(user, \"items[0].id\"); // 1\n *\n * // With default value\n * const phone = getValue(user, \"profile.phone\", \"N/A\"); // \"N/A\"\n * ```\n */\nexport function getValue<\n  TData,\n  TPath extends string,\n  TDefault = GetFieldType<TData, TPath>,\n>(\n  data: TData,\n  path: TPath,\n  defaultValue?: TDefault\n): GetFieldType<TData, TPath> | TDefault {\n  const value = path\n    .split(/[.[\\]]/)\n    .filter(Boolean)\n    .reduce<GetFieldType<TData, TPath>>(\n      (value, key) => (value as any)?.[key],\n      data as any\n    );\n\n  return value !== undefined ? value : (defaultValue as TDefault);\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/utils.types.ts",
      "target": "lib/utils.types.ts",
      "content": "type DepthCounter = [never, 1, 2, 3, 4, 5, 6];\n\nexport type DeepKeys<\n  T,\n  Prefix extends string = \"\",\n  Depth extends number = 6,\n> = [Depth] extends [never]\n  ? never\n  : T extends object\n    ? {\n        [K in keyof T]-?: K extends string\n          ?\n              | `${Prefix}${Prefix extends \"\" ? \"\" : \".\"}${K}`\n              | DeepKeys<\n                  T[K],\n                  `${Prefix}${Prefix extends \"\" ? \"\" : \".\"}${K}`,\n                  Prev<Depth>\n                >\n          : never;\n      }[keyof T]\n    : \"\";\n\ntype Prev<N extends number> = DepthCounter[N];\n\ntype FieldWithPossiblyUndefined<T, key> =\n  | GetFieldType<Exclude<T, undefined>, key>\n  | Extract<T, undefined>;\n\ntype GetIndexedField<T, K> = K extends keyof T\n  ? T[K]\n  : K extends `${number}`\n    ? \"0\" extends keyof T\n      ? undefined\n      : number extends keyof T\n        ? T[number]\n        : undefined\n    : undefined;\n\nexport type GetFieldType<T, P> = P extends `${infer Left}.${infer Right}`\n  ? Left extends keyof T\n    ? FieldWithPossiblyUndefined<T[Left], Right>\n    : Left extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ? FieldWithPossiblyUndefined<\n            | GetIndexedField<Exclude<T[FieldKey], undefined>, IndexKey>\n            | Extract<T[FieldKey], undefined>,\n            Right\n          >\n        : undefined\n      : undefined\n  : P extends keyof T\n    ? T[P]\n    : P extends `${infer FieldKey}[${infer IndexKey}]`\n      ? FieldKey extends keyof T\n        ?\n            | GetIndexedField<Exclude<T[FieldKey], undefined>, IndexKey>\n            | Extract<T[FieldKey], undefined>\n        : undefined\n      : undefined;\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/security.ts",
      "target": "lib/security.ts",
      "content": "/**\n * Security utilities - Backward compatibility export\n * \n * @deprecated Use tree-shakeable imports instead:\n * \n * @example\n * //  Tree-shakeable - only imports sanitizeSearchInput\n * import { sanitizeSearchInput } from 'tanstack-shadcn-table/lib/security/sanitize';\n * \n * //  Imports all security utilities (not tree-shakeable)\n * import { sanitizeSearchInput } from 'tanstack-shadcn-table/lib/security';\n * \n * For backward compatibility, this file re-exports from the modular structure.\n */\n\n// Re-export from modular structure for backward compatibility\nexport { sanitizeHtml, sanitizeSearchInput, sanitizeFilterValue } from './security/sanitize';\nexport { validatePaginationParams, validateSortingParams, validateFileUpload } from './security/validation';\nexport { RateLimiter } from './security/rate-limiter';\nexport { CSP_DIRECTIVES } from './security/csp';\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/i18n/index.ts",
      "target": "lib/i18n/index.ts",
      "content": "/**\n * Main i18n exports\n * \n * For tree-shaking, import translations directly from locales:\n * \n * @example\n * ```ts\n * //  Tree-shakeable - only imports English\n * import { defaultTranslations } from 'tanstack-shadcn-table/i18n/en';\n * \n * //  Imports all languages\n * import { defaultTranslations } from 'tanstack-shadcn-table/lib/i18n';\n * ```\n */\n\n// Re-export types\nexport type { TableTranslations, SupportedLanguage } from \"./types\";\n\n// Re-export utilities\nexport { t, interpolate, createTranslator } from \"./utils\";\n\n// Re-export all locales (for convenience, but not tree-shakeable)\n// For tree-shaking, import directly from ./locales/{lang}\nexport {\n  defaultTranslations,\n  turkishTranslations,\n  spanishTranslations,\n  frenchTranslations,\n  germanTranslations,\n} from \"./locales\";\n\n// Available languages map (lazy-loaded for tree-shaking)\nimport { defaultTranslations } from \"./locales/en\";\nimport { turkishTranslations } from \"./locales/tr\";\nimport { spanishTranslations } from \"./locales/es\";\nimport { frenchTranslations } from \"./locales/fr\";\nimport { germanTranslations } from \"./locales/de\";\n\nexport const availableLanguages = {\n  en: { name: \"English\", translations: defaultTranslations },\n  tr: { name: \"Trke\", translations: turkishTranslations },\n  es: { name: \"Espaol\", translations: spanishTranslations },\n  fr: { name: \"Franais\", translations: frenchTranslations },\n  de: { name: \"Deutsch\", translations: germanTranslations },\n} as const;\n\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/i18n/types.ts",
      "target": "lib/i18n/types.ts",
      "content": "/**\n * Internationalization (i18n) types for the table library\n */\n\nexport interface TableTranslations {\n  // Pagination\n  pagination: {\n    previous: string;\n    next: string;\n    first: string;\n    last: string;\n    page: string;\n    of: string;\n    rowsPerPage: string;\n    goToPage: string;\n    totalRecords: string;\n    showingXtoYofZ: string; // \"Showing {from} to {to} of {total} entries\"\n    noData: string;\n  };\n\n  // Filters\n  filters: {\n    search: string;\n    searchAllColumns: string;\n    showFilter: string;\n    hideFilter: string;\n    clearFilter: string;\n    clearAllFilters: string;\n    filterBy: string;\n    all: string;\n    true: string;\n    false: string;\n    min: string;\n    max: string;\n    from: string;\n    to: string;\n    selectOption: string;\n    noOptionsFound: string;\n    // Faceted filter\n    selectedCount: string; // \"{count} selected\"\n    clearFilters: string;\n    noResultsFound: string;\n  };\n\n  // Sorting\n  sorting: {\n    sortAscending: string;\n    sortDescending: string;\n    clearSort: string;\n    sortBy: string;\n  };\n\n  // Column management\n  columns: {\n    hide: string;\n    show: string;\n    toggleVisibility: string;\n    resetColumns: string;\n    reorderColumns: string;\n    resizeColumn: string;\n  };\n\n  // Row selection\n  selection: {\n    selectAll: string;\n    selectRow: string;\n    deselectAll: string;\n    selectedCount: string; // \"{count} selected\"\n    selectAllOnPage: string;\n    selectAllRows: string;\n  };\n\n  // Loading and errors\n  status: {\n    loading: string;\n    error: string;\n    noResults: string;\n    retry: string;\n    loadMore: string;\n  };\n\n  // Security\n  security: {\n    rateLimitExceeded: string;\n    invalidInput: string;\n    fileSizeExceeded: string;\n    fileTypeNotAllowed: string;\n    inputTooLong: string;\n  };\n\n  // Accessibility\n  accessibility: {\n    sortColumn: string;\n    filterColumn: string;\n    selectAllRows: string;\n    selectRow: string;\n    columnHeader: string;\n    tableCaption: string;\n    resizeHandle: string;\n    dragHandle: string;\n  };\n}\n\nexport type SupportedLanguage = \"en\" | \"tr\" | \"es\" | \"fr\" | \"de\";\n\n",
      "type": "registry:lib"
    },
    {
      "path": "lib/i18n/utils.ts",
      "target": "lib/i18n/utils.ts",
      "content": "/**\n * Internationalization utility functions\n */\n\nimport type { TableTranslations } from \"./types\";\n\n/**\n * Simple template string replacement function.\n * Replaces placeholders in the format `{key}` with corresponding values.\n * \n * @param template - Template string with placeholders (e.g., \"Hello {name}!\")\n * @param values - Object with values to replace placeholders\n * @returns String with placeholders replaced by values\n * \n * @example\n * ```tsx\n * import { interpolate } from 'tanstack-shadcn-table';\n * \n * const message = interpolate(\"Hello {name}!\", { name: \"World\" });\n * // Result: \"Hello World!\"\n * \n * const total = interpolate(\"Total: {count} items\", { count: 42 });\n * // Result: \"Total: 42 items\"\n * ```\n * \n * @public\n */\nexport function interpolate(\n  template: string,\n  values: Record<string, string | number>\n): string {\n  return template.replace(/\\{(\\w+)\\}/g, (match, key) => {\n    return values[key]?.toString() || match;\n  });\n}\n\n/**\n * Gets a translation value from the translations object using a dot-notation path.\n * Supports nested objects and string interpolation.\n * \n * @param translations - The translations object to extract the value from\n * @param path - Dot-notation path to the translation key (e.g., \"pagination.next\")\n * @param values - Optional object with values for string interpolation\n * @returns The translated string with interpolated values, or the path if not found\n * \n * @example\n * ```tsx\n * import { t } from 'tanstack-shadcn-table';\n * import { turkishTranslations } from 'tanstack-shadcn-table/i18n/tr';\n * \n * // Simple translation\n * const next = t(turkishTranslations, \"pagination.next\");\n * // Result: \"Sonraki\"\n * \n * // Translation with interpolation\n * const total = t(turkishTranslations, \"pagination.totalRecords\", { total: 100 });\n * // Result: \"Toplam: 100 kayt\"\n * ```\n * \n * @public\n */\nexport function t(\n  translations: TableTranslations,\n  path: string,\n  values?: Record<string, string | number>\n): string {\n  const keys = path.split(\".\");\n  let result: any = translations;\n\n  for (const key of keys) {\n    result = result?.[key];\n    if (result === undefined) {\n      console.warn(`Translation key not found: ${path}`);\n      return path;\n    }\n  }\n\n  if (typeof result !== \"string\") {\n    console.warn(`Translation value is not a string: ${path}`);\n    return path;\n  }\n\n  return values ? interpolate(result, values) : result;\n}\n\n/**\n * Creates a translation function bound to specific translations.\n * This is useful for creating a reusable translator function that doesn't require\n * passing the translations object every time.\n * \n * @param translations - The translations object to bind to the translator function\n * @returns A function that takes a path and optional values, returning the translated string\n * \n * @example\n * ```tsx\n * import { createTranslator } from 'tanstack-shadcn-table';\n * import { turkishTranslations } from 'tanstack-shadcn-table/i18n/tr';\n * \n * // Create a bound translator\n * const t = createTranslator(turkishTranslations);\n * \n * // Use the translator\n * const next = t(\"pagination.next\"); // \"Sonraki\"\n * const total = t(\"pagination.totalRecords\", { total: 100 }); // \"Toplam: 100 kayt\"\n * ```\n * \n * @public\n */\nexport function createTranslator(translations: TableTranslations) {\n  return (path: string, values?: Record<string, string | number>) =>\n    t(translations, path, values);\n}\n\n",
      "type": "registry:lib"
    },
    {
      "path": "types/types.ts",
      "target": "types/types.ts",
      "content": "import {\n  ColumnDef as TSColumnDef,\n  Column as TSColumn,\n  GroupColumnDef as TSGroupColumnDef,\n  DeepKeys,\n  CellContext,\n  ColumnFiltersState,\n  PaginationState,\n  ColumnSizingState,\n} from \"@tanstack/react-table\";\nimport { TableTranslations } from \"../lib/i18n\";\n\n/**\n * Main configuration object for the DataTable component.\n * \n * @template T - The type of data in each row\n * \n * @example\n * ```tsx\n * const tableOptions: TableOptions<Person> = {\n *   data: people,\n *   columns: personColumns,\n *   pagination: {\n *     pageSize: 10,\n *     totalRecords: 100,\n *   },\n *   filter: true,\n *   globalFilter: {\n *     show: true,\n *   },\n * };\n * ```\n */\nexport type TableOptions<T> = {\n  data: T[];\n  columns: ColumnDef<T>[];\n  globalFilter?: GlobalFilterType;\n  filterRowClassName?: string;\n  rowClassName?: string;\n  colClassName?: string;\n  filter?: boolean;\n  reorderable?: boolean;\n  showFilterButton?: boolean;\n  pagination?: PaginationOptions;\n\n  // Column sizing options\n  enableColumnResizing?: boolean;\n  columnResizeMode?: \"onChange\" | \"onEnd\";\n  columnResizeDirection?: \"ltr\" | \"rtl\";\n  fillTableWidth?: boolean;\n\n  // Internationalization\n  translations?: TableTranslations;\n} & Lazy &\n  Sorting &\n  ColumnFilters &\n  Pagination &\n  ColumnVisibility &\n  ColumnOrder &\n  RowSelection &\n  ColumnSizing &\n  ShowFilter;\n\ntype ColumnVisibility =\n  | {\n      columnVisibility?: Record<string, boolean>;\n      onColumnVisibilityChange?: (visibility: Record<string, boolean>) => void;\n    }\n  | {\n      columnVisibility?: never;\n      onColumnVisibilityChange?: never;\n    };\n\ntype Pagination =\n  | {\n      paginationState?: PaginationState;\n      onPaginationChange?: (pagination: PaginationState) => void;\n    }\n  | {\n      paginationState?: never;\n      onPaginationChange?: never;\n    };\n\ntype ColumnFilters =\n  | {\n      columnFilters?: ColumnFiltersState;\n      onColumnFiltersChange?: (filters: ColumnFiltersState) => void;\n    }\n  | {\n      columnFilters?: never;\n      onColumnFiltersChange?: never;\n    };\n\ntype Sorting =\n  | {\n      sorting?: SortingState[];\n      onSortingChange?: (sorting: SortingState[]) => void;\n    }\n  | {\n      sorting?: never;\n      onSortingChange?: never;\n    };\n\ntype Lazy =\n  | {\n      lazy: true;\n      onLazyLoad: (event: LazyLoadEvent) => void;\n    }\n  | {\n      lazy?: false;\n      onLazyLoad?: never;\n    };\n\ntype ColumnOrder =\n  | {\n      columnOrder?: string[];\n      onColumnOrderChange?: (order: string[]) => void;\n    }\n  | {\n      columnOrder?: never;\n      onColumnOrderChange?: never;\n    };\n\ntype RowSelection =\n  | {\n      rowSelection?: Record<string, boolean>;\n      onRowSelectionChange?: (selection: Record<string, boolean>) => void;\n      enableRowSelectionFn?: (row: any) => boolean;\n    }\n  | {\n      rowSelection?: never;\n      onRowSelectionChange?: never;\n      enableRowSelectionFn?: never;\n    };\n\ntype ShowFilter =\n  | {\n      showFilter?: boolean;\n      onShowFilterChange?: (show: boolean) => void;\n    }\n  | {\n      showFilter?: never;\n      onShowFilterChange?: never;\n    };\n\ntype GlobalFilterType = {\n  show?: boolean;\n  globalFilter?: string;\n  onGlobalFilterChange?: (filter: string) => void;\n};\n\ntype ColumnSizing =\n  | {\n      columnSizing?: ColumnSizingState;\n      onColumnSizingChange?: (sizing: ColumnSizingState) => void;\n      defaultColumn?: {\n        size?: number;\n        minSize?: number;\n        maxSize?: number;\n      };\n    }\n  | {\n      columnSizing?: never;\n      onColumnSizingChange?: never;\n      defaultColumn?: never;\n    };\n\n/**\n * Column definition for DataTable.\n * Extends TanStack Table's ColumnDef with additional filter and styling options.\n * \n * @template T - The type of data in each row\n * \n * @example\n * ```tsx\n * const columns: ColumnDef<Person>[] = [\n *   {\n *     accessorKey: \"firstName\",\n *     header: \"First Name\",\n *     filter: {\n *       type: \"text\",\n *       field: \"firstName\",\n *       placeholder: \"Search...\",\n *     },\n *   },\n *   {\n *     accessorKey: \"age\",\n *     header: \"Age\",\n *     filter: {\n *       type: \"range\",\n *       field: \"age\",\n *     },\n *     size: 100,\n *     minSize: 50,\n *     maxSize: 200,\n *   },\n * ];\n * ```\n */\nexport type ColumnDef<T> = {\n  filter?: FilterType<T>;\n  cell?: (info: CellContext<T, unknown>) => any;\n  sortField?: string;\n  className?: string;\n  headerClassName?: string;\n  footerClassName?: string;\n  reorderable?: boolean;\n\n  // Column sizing properties\n  size?: number;\n  minSize?: number;\n  maxSize?: number;\n  enableResizing?: boolean;\n} & (\n  | (\n      | {\n          accessorFn: (row: T) => any;\n          id: string;\n          accessorKey?: never;\n          columns?: never;\n        }\n      | {\n          accessorKey: DeepKeys<T>;\n          accessorFn?: never;\n          id?: string;\n          columns?: never;\n        }\n    )\n  | {\n      columns: ColumnDef<T>[];\n      accessorFn?: never;\n      accessorKey?: never;\n      id?: string;\n    }\n) &\n  TSColumnDef<T, unknown>;\n\nexport type Column<T> = {\n  columnDef: ColumnDef<T>;\n} & TSColumn<T, unknown>;\n\nexport type GroupColumnDef<T> = {\n  columns?: ColumnDef<T>[];\n} & TSGroupColumnDef<T, unknown>;\n\n/**\n * Filter configuration for a column.\n * Supports multiple filter types: text, range, select, boolean, date, and custom.\n * \n * @template T - The type of data in each row\n * \n * @example\n * ```tsx\n * // Text filter\n * {\n *   type: \"text\",\n *   field: \"firstName\",\n *   placeholder: \"Search first name...\",\n * }\n * \n * // Range filter\n * {\n *   type: \"range\",\n *   field: \"age\",\n *   minPlaceholder: \"Min age\",\n *   maxPlaceholder: \"Max age\",\n * }\n * \n * // Select filter\n * {\n *   type: \"select\",\n *   field: \"status\",\n *   options: [\n *     { label: \"Active\", value: \"active\" },\n *     { label: \"Inactive\", value: \"inactive\" },\n *   ],\n *   optionLabel: \"label\",\n *   optionValue: \"value\",\n * }\n * ```\n */\nexport type FilterType<T> = {\n  field: string;\n  className?: string;\n} & (\n  | {\n      type: \"text\";\n      placeholder: string;\n      showList?: boolean;\n      showTotal?: boolean;\n    }\n  | {\n      type: \"range\";\n      minPlaceholder?: string;\n      maxPlaceholder?: string;\n      showLimit?: boolean;\n      minLimit?: number | \"faceted\";\n      maxLimit?: number | \"faceted\";\n    }\n  | {\n      type: \"select\" | \"multi-select\";\n      options: any[];\n      optionLabel: string;\n      optionValue: string;\n      allLabel?: string;\n    }\n  | {\n      type: \"boolean\";\n      trueLabel?: string;\n      falseLabel?: string;\n      allLabel?: string;\n    }\n  | {\n      type: \"date\";\n    }\n  | {\n      type: \"date-range\";\n    }\n  | {\n      type: \"custom\";\n      component: React.ComponentType<{ column: Column<T> }>;\n    }\n);\n\n/**\n * Pagination configuration options.\n * \n * @example\n * ```tsx\n * const pagination: PaginationOptions = {\n *   pageSize: 10,\n *   totalRecords: 100,\n *   pageSizeOptions: [5, 10, 20, 50],\n *   mode: \"advanced\",\n *   layout: [\"total\", \"pageSize\", \"goto\", \"buttons\"],\n * };\n * ```\n */\nexport type PaginationOptions = {\n  pageSizeOptions?: number[];\n  pageSize: number;\n  totalRecords: number;\n  mode?: \"advanced\" | \"default\" | \"compact\";\n  maxVisiblePages?: number;\n  goToPageLabel?: string;\n  pageSizeLabel?: string;\n  className?: string;\n  totalLabel?: string;\n  layout?: (\"total\" | \"pageSize\" | \"goto\" | \"buttons\")[];\n};\n\n/**\n * Event object passed to the onLazyLoad callback when lazy loading is enabled.\n * Contains all the necessary information to fetch data from the server.\n * \n * @example\n * ```tsx\n * const handleLazyLoad = async (event: LazyLoadEvent) => {\n *   const response = await fetch(\"/api/data\", {\n *     method: \"POST\",\n *     body: JSON.stringify({\n *       page: event.page,\n *       pageSize: event.rows,\n *       filters: event.filters,\n *       sorting: event.sorting,\n *       globalFilter: event.globalFilter,\n *     }),\n *   });\n *   const result = await response.json();\n *   setData(result.data);\n * };\n * ```\n */\nexport type LazyLoadEvent = {\n  first: number;\n  rows: number;\n  filters: ColumnFiltersState;\n  globalFilter: string;\n  sorting: SortingState[];\n  page: number;\n};\n\nexport type SortingState = {\n  id: string;\n  desc: boolean;\n};\n",
      "type": "registry:file"
    }
  ],
  "tailwind": {
    "config": {
      "theme": {
        "extend": {}
      }
    }
  }
}